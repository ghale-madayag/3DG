import {
  CKEditorError,
  Collection,
  DomEmitterMixin,
  EmitterMixin,
  FocusTracker,
  KeystrokeHandler,
  ObservableMixin,
  Rect,
  ResizeObserver,
  delay,
  env_default,
  first,
  getEnvKeystrokeText,
  getOptimalPosition,
  global_default,
  icons,
  isIterable,
  isNode,
  isRange,
  isVisible,
  toArray,
  toUnit,
  uid,
  verifyLicense
} from "./chunk-W4RSC2T7.js";
import {
  assignIn_default,
  cloneDeepWith_default,
  debounce_default,
  escapeRegExp_default,
  isElement_default,
  isObject_default,
  throttle_default
} from "./chunk-5NSBEPH7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert2 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert2;
    for (const model of Object.keys(convert2)) {
      if (!("channels" in convert2[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert2[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert2[model].labels.length !== convert2[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert2[model];
      delete convert2[model].channels;
      delete convert2[model].labels;
      Object.defineProperty(convert2[model], "channels", { value: channels });
      Object.defineProperty(convert2[model], "labels", { value: labels });
    }
    convert2.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert2.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert2.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert2.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert2.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert2.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert2.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert2.rgb.lab = function(rgb) {
      const xyz = convert2.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert2.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert2.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert2.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert2.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert2.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert2.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert2.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert2.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert2.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert2.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert2.hsv.ansi16 = function(args) {
      return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
    };
    convert2.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert2.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert2.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert2.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert2.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert2.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert2.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert2.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert2.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert2.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert2.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert2.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert2.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert2.gray.hsv = convert2.gray.hsl;
    convert2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert2.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert2 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert2;
  }
});

// node_modules/@ckeditor/ckeditor5-ui/src/viewcollection.js
var ViewCollection = class extends Collection {
  /**
   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
   *
   * @param initialItems The initial items of the collection.
   */
  constructor(initialItems = []) {
    super(initialItems, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: "viewUid"
    });
    this.on("add", (evt, view, index) => {
      this._renderViewIntoCollectionParent(view, index);
    });
    this.on("remove", (evt, view) => {
      if (view.element && this._parentElement) {
        view.element.remove();
      }
    });
    this._parentElement = null;
  }
  /**
   * Destroys the view collection along with child views.
   * See the view {@link module:ui/view~View#destroy} method.
   */
  destroy() {
    this.map((view) => view.destroy());
  }
  /**
   * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
   * {@link #remove removing} views in the collection synchronizes their
   * {@link module:ui/view~View#element elements} in the parent element.
   *
   * @param element A new parent element.
   */
  setParent(elementOrDocFragment) {
    this._parentElement = elementOrDocFragment;
    for (const view of this) {
      this._renderViewIntoCollectionParent(view);
    }
  }
  /**
   * Delegates selected events coming from within views in the collection to any
   * {@link module:utils/emittermixin~Emitter}.
   *
   * For the following views and collection:
   *
   * ```ts
   * const viewA = new View();
   * const viewB = new View();
   * const viewC = new View();
   *
   * const views = parentView.createCollection();
   *
   * views.delegate( 'eventX' ).to( viewB );
   * views.delegate( 'eventX', 'eventY' ).to( viewC );
   *
   * views.add( viewA );
   * ```
   *
   * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventX', customData );
   * ```
   *
   * and `eventY` is delegated (fired by) `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventY', customData );
   * ```
   *
   * See {@link module:utils/emittermixin~Emitter#delegate}.
   *
   * @param events {@link module:ui/view~View} event names to be delegated to another
   * {@link module:utils/emittermixin~Emitter}.
   * @returns Object with `to` property, a function which accepts the destination
   * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
   */
  delegate(...events) {
    if (!events.length || !isStringArray(events)) {
      throw new CKEditorError("ui-viewcollection-delegate-wrong-events", this);
    }
    return {
      to: (dest) => {
        for (const view of this) {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        }
        this.on("add", (evt, view) => {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        });
        this.on("remove", (evt, view) => {
          for (const evtName of events) {
            view.stopDelegating(evtName, dest);
          }
        });
      }
    };
  }
  /**
   * This method {@link module:ui/view~View#render renders} a new view added to the collection.
   *
   * If the {@link #_parentElement parent element} of the collection is set, this method also adds
   * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
   *
   * **Note**: If index is not specified, the view's element is pushed as the last child
   * of the parent element.
   *
   * @param view A new view added to the collection.
   * @param index An index the view holds in the collection. When not specified,
   * the view is added at the end.
   */
  _renderViewIntoCollectionParent(view, index) {
    if (!view.isRendered) {
      view.render();
    }
    if (view.element && this._parentElement) {
      this._parentElement.insertBefore(view.element, this._parentElement.children[index]);
    }
  }
  /**
   * Removes a child view from the collection. If the {@link #setParent parent element} of the
   * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
   * in DOM, reflecting the order of the collection.
   *
   * See the {@link #add} method.
   *
   * @param subject The view to remove, its id or index in the collection.
   * @returns The removed view.
   */
  remove(subject) {
    return super.remove(subject);
  }
};
function isStringArray(arr) {
  return arr.every((a) => typeof a == "string");
}

// node_modules/@ckeditor/ckeditor5-ui/src/template.js
var xhtmlNs = "http://www.w3.org/1999/xhtml";
var Template = class extends EmitterMixin() {
  /**
   * Creates an instance of the {@link ~Template} class.
   *
   * @param def The definition of the template.
   */
  constructor(def) {
    super();
    Object.assign(this, normalize(clone(def)));
    this._isRendered = false;
    this._revertData = null;
  }
  /**
   * Renders a DOM Node (an HTML element or text) out of the template.
   *
   * ```ts
   * const domNode = new Template( { ... } ).render();
   * ```
   *
   * See: {@link #apply}.
   */
  render() {
    const node = this._renderNode({
      intoFragment: true
    });
    this._isRendered = true;
    return node;
  }
  /**
   * Applies the template to an existing DOM Node, either HTML element or text.
   *
   * **Note:** No new DOM nodes will be created. Applying extends:
   *
   * {@link module:ui/template~TemplateDefinition attributes},
   * {@link module:ui/template~TemplateDefinition event listeners}, and
   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
   *
   * **Note:** Existing `class` and `style` attributes are extended when a template
   * is applied to an HTML element, while other attributes and `textContent` are overridden.
   *
   * **Note:** The process of applying a template can be easily reverted using the
   * {@link module:ui/template~Template#revert} method.
   *
   * ```ts
   * const element = document.createElement( 'div' );
   * const observable = new Model( { divClass: 'my-div' } );
   * const emitter = Object.create( EmitterMixin );
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		id: 'first-div',
   * 		class: bind.to( 'divClass' )
   * 	},
   * 	on: {
   * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
   * 	},
   * 	children: [
   * 		'Div text.'
   * 	]
   * } ).apply( element );
   *
   * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
   * ```
   *
   * @see module:ui/template~Template#render
   * @see module:ui/template~Template#revert
   * @param node Root node for the template to apply.
   */
  apply(node) {
    this._revertData = getEmptyRevertData();
    this._renderNode({
      node,
      intoFragment: false,
      isApplying: true,
      revertData: this._revertData
    });
    return node;
  }
  /**
   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
   *
   * @param node The root node for the template to revert. In most of the cases, it is the
   * same node used by {@link module:ui/template~Template#apply}.
   */
  revert(node) {
    if (!this._revertData) {
      throw new CKEditorError("ui-template-revert-not-applied", [this, node]);
    }
    this._revertTemplateFromNode(node, this._revertData);
  }
  /**
   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
   * instances and returns them one by one.
   *
   * ```ts
   * const viewFoo = new View();
   * const viewBar = new View();
   * const viewBaz = new View();
   * const template = new Template( {
   * 	tag: 'div',
   * 	children: [
   * 		viewFoo,
   * 		{
   * 			tag: 'div',
   * 			children: [
   * 				viewBar
   * 			]
   * 		},
   * 		viewBaz
   * 	]
   * } );
   *
   * // Logs: viewFoo, viewBar, viewBaz
   * for ( const view of template.getViews() ) {
   * 	console.log( view );
   * }
   * ```
   */
  *getViews() {
    function* search(def) {
      if (def.children) {
        for (const child of def.children) {
          if (isView(child)) {
            yield child;
          } else if (isTemplate(child)) {
            yield* search(child);
          }
        }
      }
    }
    yield* search(this);
  }
  /**
   * An entry point to the interface which binds DOM nodes to
   * {@link module:utils/observablemixin~Observable observables}.
   * There are two types of bindings:
   *
   * * HTML element attributes or text `textContent` synchronized with attributes of an
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
   * and {@link module:ui/template~BindChain#if}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		// Binds the element "class" attribute to observable#classAttribute.
   * 		class: bind.to( 'classAttribute' )
   * 	}
   * } ).render();
   * ```
   *
   * * DOM events fired on HTML element propagated through
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	on: {
   * 		// Will be fired by the observable.
   * 		click: bind( 'elementClicked' )
   * 	}
   * } ).render();
   * ```
   *
   * Also see {@link module:ui/view~View#bindTemplate}.
   *
   * @param observable An observable which provides boundable attributes.
   * @param emitter An emitter that listens to observable attribute
   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
   */
  static bind(observable, emitter) {
    return {
      to(eventNameOrFunctionOrAttribute, callback) {
        return new TemplateToBinding({
          eventNameOrFunction: eventNameOrFunctionOrAttribute,
          attribute: eventNameOrFunctionOrAttribute,
          observable,
          emitter,
          callback
        });
      },
      if(attribute, valueIfTrue, callback) {
        return new TemplateIfBinding({
          observable,
          emitter,
          attribute,
          valueIfTrue,
          callback
        });
      }
    };
  }
  /**
   * Extends an existing {@link module:ui/template~Template} instance with some additional content
   * from another {@link module:ui/template~TemplateDefinition}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * const template = new Template( {
   * 	tag: 'p',
   * 	attributes: {
   * 		class: 'a',
   * 		data-x: bind.to( 'foo' )
   * 	},
   * 	children: [
   * 		{
   * 			tag: 'span',
   * 			attributes: {
   * 				class: 'b'
   * 			},
   * 			children: [
   * 				'Span'
   * 			]
   * 		}
   * 	]
   *  } );
   *
   * // Instance-level extension.
   * Template.extend( template, {
   * 	attributes: {
   * 		class: 'b',
   * 		data-x: bind.to( 'bar' )
   * 	},
   * 	children: [
   * 		{
   * 			attributes: {
   * 				class: 'c'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Child extension.
   * Template.extend( template.children[ 0 ], {
   * 	attributes: {
   * 		class: 'd'
   * 	}
   * } );
   * ```
   *
   * the `outerHTML` of `template.render()` is:
   *
   * ```html
   * <p class="a b" data-x="{ observable.foo } { observable.bar }">
   * 	<span class="b c d">Span</span>
   * </p>
   * ```
   *
   * @param template An existing template instance to be extended.
   * @param def Additional definition to be applied to a template.
   */
  static extend(template, def) {
    if (template._isRendered) {
      throw new CKEditorError("template-extend-render", [this, template]);
    }
    extendTemplate(template, normalize(clone(def)));
  }
  /**
   * Renders a DOM Node (either an HTML element or text) out of the template.
   *
   * @param data Rendering data.
   */
  _renderNode(data) {
    let isInvalid;
    if (data.node) {
      isInvalid = this.tag && this.text;
    } else {
      isInvalid = this.tag ? this.text : !this.text;
    }
    if (isInvalid) {
      throw new CKEditorError("ui-template-wrong-syntax", this);
    }
    if (this.text) {
      return this._renderText(data);
    } else {
      return this._renderElement(data);
    }
  }
  /**
   * Renders an HTML element out of the template.
   *
   * @param data Rendering data.
   */
  _renderElement(data) {
    let node = data.node;
    if (!node) {
      node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
    }
    this._renderAttributes(data);
    this._renderElementChildren(data);
    this._setUpListeners(data);
    return node;
  }
  /**
   * Renders a text node out of {@link module:ui/template~Template#text}.
   *
   * @param data Rendering data.
   */
  _renderText(data) {
    let node = data.node;
    if (node) {
      data.revertData.text = node.textContent;
    } else {
      node = data.node = document.createTextNode("");
    }
    if (hasTemplateBinding(this.text)) {
      this._bindToObservable({
        schema: this.text,
        updater: getTextUpdater(node),
        data
      });
    } else {
      node.textContent = this.text.join("");
    }
    return node;
  }
  /**
   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
   *
   * @param data Rendering data.
   */
  _renderAttributes(data) {
    if (!this.attributes) {
      return;
    }
    const node = data.node;
    const revertData = data.revertData;
    for (const attrName in this.attributes) {
      const domAttrValue = node.getAttribute(attrName);
      const attrValue = this.attributes[attrName];
      if (revertData) {
        revertData.attributes[attrName] = domAttrValue;
      }
      const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
      if (hasTemplateBinding(attrValue)) {
        const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
        if (revertData && shouldExtend(attrName)) {
          valueToBind.unshift(domAttrValue);
        }
        this._bindToObservable({
          schema: valueToBind,
          updater: getAttributeUpdater(node, attrName, attrNs),
          data
        });
      } else if (attrName == "style" && typeof attrValue[0] !== "string") {
        this._renderStyleAttribute(attrValue[0], data);
      } else {
        if (revertData && domAttrValue && shouldExtend(attrName)) {
          attrValue.unshift(domAttrValue);
        }
        const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
        if (!isFalsy(value)) {
          node.setAttributeNS(attrNs, attrName, value);
        }
      }
    }
  }
  /**
   * Renders the `style` attribute of an HTML element based on
   * {@link module:ui/template~Template#attributes}.
   *
   * A style attribute is an object with static values:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: 'red'
   * 	}
   * }
   * ```
   *
   * or values bound to {@link module:ui/model~Model} properties:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: bind.to( ... )
   * 	}
   * }
   * ```
   *
   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
   * needed.
   *
   * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
   * @param data Rendering data.
   */
  _renderStyleAttribute(styles, data) {
    const node = data.node;
    for (const styleName in styles) {
      const styleValue = styles[styleName];
      if (hasTemplateBinding(styleValue)) {
        this._bindToObservable({
          schema: [styleValue],
          updater: getStyleUpdater(node, styleName),
          data
        });
      } else {
        node.style[styleName] = styleValue;
      }
    }
  }
  /**
   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
   *
   * @param data Rendering data.
   */
  _renderElementChildren(data) {
    const node = data.node;
    const container = data.intoFragment ? document.createDocumentFragment() : node;
    const isApplying = data.isApplying;
    let childIndex = 0;
    for (const child of this.children) {
      if (isViewCollection(child)) {
        if (!isApplying) {
          child.setParent(node);
          for (const view of child) {
            container.appendChild(view.element);
          }
        }
      } else if (isView(child)) {
        if (!isApplying) {
          if (!child.isRendered) {
            child.render();
          }
          container.appendChild(child.element);
        }
      } else if (isNode(child)) {
        container.appendChild(child);
      } else {
        if (isApplying) {
          const revertData = data.revertData;
          const childRevertData = getEmptyRevertData();
          revertData.children.push(childRevertData);
          child._renderNode({
            intoFragment: false,
            node: container.childNodes[childIndex++],
            isApplying: true,
            revertData: childRevertData
          });
        } else {
          container.appendChild(child.render());
        }
      }
    }
    if (data.intoFragment) {
      node.appendChild(container);
    }
  }
  /**
   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
   * on an HTML element.
   *
   * @param data Rendering data.
   */
  _setUpListeners(data) {
    if (!this.eventListeners) {
      return;
    }
    for (const key in this.eventListeners) {
      const revertBindings = this.eventListeners[key].map((schemaItem) => {
        const [domEvtName, domSelector] = key.split("@");
        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
      });
      if (data.revertData) {
        data.revertData.bindings.push(revertBindings);
      }
    }
  }
  /**
   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
   * activates the binding and sets its initial value.
   *
   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
   * text node `textContent`.
   *
   * @param options Binding options.
   * @param options.updater A function which updates the DOM (like attribute or text).
   * @param options.data Rendering data.
   */
  _bindToObservable({ schema, updater, data }) {
    const revertData = data.revertData;
    syncValueSchemaValue(schema, updater, data);
    const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
    if (revertData) {
      revertData.bindings.push(revertBindings);
    }
  }
  /**
   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
   * return it to the original state.
   *
   * @param node A node to be reverted.
   * @param revertData An object that stores information about what changes have been made by
   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
   */
  _revertTemplateFromNode(node, revertData) {
    for (const binding of revertData.bindings) {
      for (const revertBinding of binding) {
        revertBinding();
      }
    }
    if (revertData.text) {
      node.textContent = revertData.text;
      return;
    }
    const element = node;
    for (const attrName in revertData.attributes) {
      const attrValue = revertData.attributes[attrName];
      if (attrValue === null) {
        element.removeAttribute(attrName);
      } else {
        element.setAttribute(attrName, attrValue);
      }
    }
    for (let i = 0; i < revertData.children.length; ++i) {
      this._revertTemplateFromNode(element.childNodes[i], revertData.children[i]);
    }
  }
};
var TemplateBinding = class {
  /**
   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
   *
   * @param def The definition of the binding.
   */
  constructor(def) {
    this.attribute = def.attribute;
    this.observable = def.observable;
    this.emitter = def.emitter;
    this.callback = def.callback;
  }
  /**
   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
   *
   * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
   * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}.
   */
  getValue(node) {
    const value = this.observable[this.attribute];
    return this.callback ? this.callback(value, node) : value;
  }
  /**
   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
   * value of {@link module:ui/template~TemplateValueSchema}.
   *
   * @param schema A full schema to generate an attribute or text in the DOM.
   * @param updater A DOM updater function used to update the native DOM attribute or text.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateAttributeListener(schema, updater, data) {
    const callback = () => syncValueSchemaValue(schema, updater, data);
    this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
    return () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
    };
  }
};
var TemplateToBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.eventNameOrFunction = def.eventNameOrFunction;
  }
  /**
   * Activates the listener for the native DOM event, which when fired, is propagated by
   * the {@link module:ui/template~TemplateBinding#emitter}.
   *
   * @param domEvtName The name of the native DOM event.
   * @param domSelector The selector in the DOM to filter delegated events.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateDomEventListener(domEvtName, domSelector, data) {
    const callback = (evt, domEvt) => {
      if (!domSelector || domEvt.target.matches(domSelector)) {
        if (typeof this.eventNameOrFunction == "function") {
          this.eventNameOrFunction(domEvt);
        } else {
          this.observable.fire(this.eventNameOrFunction, domEvt);
        }
      }
    };
    this.emitter.listenTo(data.node, domEvtName, callback);
    return () => {
      this.emitter.stopListening(data.node, domEvtName, callback);
    };
  }
};
var TemplateIfBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.valueIfTrue = def.valueIfTrue;
  }
  /**
   * @inheritDoc
   */
  getValue(node) {
    const value = super.getValue(node);
    return isFalsy(value) ? false : this.valueIfTrue || true;
  }
};
function hasTemplateBinding(schema) {
  if (!schema) {
    return false;
  }
  if (schema.value) {
    schema = schema.value;
  }
  if (Array.isArray(schema)) {
    return schema.some(hasTemplateBinding);
  } else if (schema instanceof TemplateBinding) {
    return true;
  }
  return false;
}
function getValueSchemaValue(schema, node) {
  return schema.map((schemaItem) => {
    if (schemaItem instanceof TemplateBinding) {
      return schemaItem.getValue(node);
    }
    return schemaItem;
  });
}
function syncValueSchemaValue(schema, updater, { node }) {
  const values = getValueSchemaValue(schema, node);
  let value;
  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
    value = values[0];
  } else {
    value = values.reduce(arrayValueReducer, "");
  }
  if (isFalsy(value)) {
    updater.remove();
  } else {
    updater.set(value);
  }
}
function getTextUpdater(node) {
  return {
    set(value) {
      node.textContent = value;
    },
    remove() {
      node.textContent = "";
    }
  };
}
function getAttributeUpdater(el, attrName, ns) {
  return {
    set(value) {
      el.setAttributeNS(ns, attrName, value);
    },
    remove() {
      el.removeAttributeNS(ns, attrName);
    }
  };
}
function getStyleUpdater(el, styleName) {
  return {
    set(value) {
      el.style[styleName] = value;
    },
    remove() {
      el.style[styleName] = null;
    }
  };
}
function clone(def) {
  const clone2 = cloneDeepWith_default(def, (value) => {
    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
      return value;
    }
  });
  return clone2;
}
function normalize(def) {
  if (typeof def == "string") {
    def = normalizePlainTextDefinition(def);
  } else if (def.text) {
    normalizeTextDefinition(def);
  }
  if (def.on) {
    def.eventListeners = normalizeListeners(def.on);
    delete def.on;
  }
  if (!def.text) {
    if (def.attributes) {
      normalizeAttributes(def.attributes);
    }
    const children = [];
    if (def.children) {
      if (isViewCollection(def.children)) {
        children.push(def.children);
      } else {
        for (const child of def.children) {
          if (isTemplate(child) || isView(child) || isNode(child)) {
            children.push(child);
          } else {
            children.push(new Template(child));
          }
        }
      }
    }
    def.children = children;
  }
  return def;
}
function normalizeAttributes(attributes) {
  for (const a in attributes) {
    if (attributes[a].value) {
      attributes[a].value = toArray(attributes[a].value);
    }
    arrayify(attributes, a);
  }
}
function normalizeListeners(listeners) {
  for (const l in listeners) {
    arrayify(listeners, l);
  }
  return listeners;
}
function normalizePlainTextDefinition(def) {
  return {
    text: [def]
  };
}
function normalizeTextDefinition(def) {
  def.text = toArray(def.text);
}
function arrayify(obj, key) {
  obj[key] = toArray(obj[key]);
}
function arrayValueReducer(prev, cur) {
  if (isFalsy(cur)) {
    return prev;
  } else if (isFalsy(prev)) {
    return cur;
  } else {
    return `${prev} ${cur}`;
  }
}
function extendObjectValueArray(obj, ext) {
  for (const a in ext) {
    if (obj[a]) {
      obj[a].push(...ext[a]);
    } else {
      obj[a] = ext[a];
    }
  }
}
function extendTemplate(template, def) {
  if (def.attributes) {
    if (!template.attributes) {
      template.attributes = {};
    }
    extendObjectValueArray(template.attributes, def.attributes);
  }
  if (def.eventListeners) {
    if (!template.eventListeners) {
      template.eventListeners = {};
    }
    extendObjectValueArray(template.eventListeners, def.eventListeners);
  }
  if (def.text) {
    template.text.push(...def.text);
  }
  if (def.children && def.children.length) {
    if (template.children.length != def.children.length) {
      throw new CKEditorError("ui-template-extend-children-mismatch", template);
    }
    let childIndex = 0;
    for (const childDef of def.children) {
      extendTemplate(template.children[childIndex++], childDef);
    }
  }
}
function isFalsy(value) {
  return !value && value !== 0;
}
function isView(item) {
  return item instanceof View;
}
function isTemplate(item) {
  return item instanceof Template;
}
function isViewCollection(item) {
  return item instanceof ViewCollection;
}
function isNamespaced(attrValue) {
  return isObject_default(attrValue[0]) && attrValue[0].ns;
}
function getEmptyRevertData() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function shouldExtend(attrName) {
  return attrName == "class" || attrName == "style";
}

// node_modules/@ckeditor/ckeditor5-ui/src/view.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/globals/globals.css";
var View = class extends DomEmitterMixin(ObservableMixin()) {
  /**
   * Creates an instance of the {@link module:ui/view~View} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super();
    this.element = null;
    this.isRendered = false;
    this.locale = locale;
    this.t = locale && locale.t;
    this._viewCollections = new Collection();
    this._unboundChildren = this.createCollection();
    this._viewCollections.on("add", (evt, collection) => {
      collection.locale = locale;
      collection.t = locale && locale.t;
    });
    this.decorate("render");
  }
  /**
   * Shorthand for {@link module:ui/template~Template.bind}, a binding
   * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
   *
   * It provides {@link module:ui/template~BindChain#to `to()`} and
   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
   * observable attributes and attach DOM listeners.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const bind = this.bindTemplate;
   *
   * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
   * 		// the state of the view in DOM.
   * 		this.set( {
   * 			elementClass: 'foo',
   * 		 	isEnabled: true
   * 		 } );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			attributes: {
   * 				// The class HTML attribute will follow elementClass
   * 				// and isEnabled view attributes.
   * 				class: [
   * 					bind.to( 'elementClass' )
   * 					bind.if( 'isEnabled', 'present-when-enabled' )
   * 				]
   * 			},
   *
   * 			on: {
   * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
   * 				click: bind.to( 'clicked' )
   * 			}
   * 		} );
   * 	}
   * }
   * ```
   */
  get bindTemplate() {
    if (this._bindTemplate) {
      return this._bindTemplate;
    }
    return this._bindTemplate = Template.bind(this, this);
  }
  /**
   * Creates a new collection of views, which can be used as
   * {@link module:ui/template~Template#children} of this view.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const child = new ChildView( locale );
   * 		this.items = this.createCollection( [ child ] );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// `items` collection will render here.
   * 			children: this.items
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   * view.render();
   *
   * // It will append <p><child#element></p> to the <body>.
   * document.body.appendChild( view.element );
   * ```
   *
   * @param views Initial views of the collection.
   * @returns A new collection of view instances.
   */
  createCollection(views) {
    const collection = new ViewCollection(views);
    this._viewCollections.add(collection);
    return collection;
  }
  /**
   * Registers a new child view under the view instance. Once registered, a child
   * view is managed by its parent, including {@link #render rendering}
   * and {@link #destroy destruction}.
   *
   * To revert this, use {@link #deregisterChild}.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( { tag: 'p' } );
   *
   * 		// Register the children.
   * 		this.registerChild( [ this.childA, this.childB ] );
   * 	}
   *
   * 	render() {
   * 		super.render();
   *
   * 		this.element.appendChild( this.childA.element );
   * 		this.element.appendChild( this.childB.element );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   *
   * view.render();
   *
   * // Will append <p><childA#element><b></b><childB#element></p>.
   * document.body.appendChild( view.element );
   * ```
   *
   * **Note**: There's no need to add child views if they're already referenced in the
   * {@link #template}:
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// These children will be added automatically. There's no
   * 			// need to call {@link #registerChild} for any of them.
   * 			children: [ this.childA, this.childB ]
   * 		} );
   * 	}
   *
   * 	// ...
   * }
   * ```
   *
   * @param children Children views to be registered.
   */
  registerChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.add(child);
    }
  }
  /**
   * The opposite of {@link #registerChild}. Removes a child view from this view instance.
   * Once removed, the child is no longer managed by its parent, e.g. it can safely
   * become a child of another parent view.
   *
   * @see #registerChild
   * @param children Child views to be removed.
   */
  deregisterChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.remove(child);
    }
  }
  /**
   * Sets the {@link #template} of the view with with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * view.setTemplate( definition );
   * ```
   *
   * @param definition Definition of view's template.
   */
  setTemplate(definition) {
    this.template = new Template(definition);
  }
  /**
   * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
   * with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * Template.extend( view.template, definition );
   * ```
   *
   * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
   *
   * @param definition Definition which extends the {@link #template}.
   */
  extendTemplate(definition) {
    Template.extend(this.template, definition);
  }
  /**
   * Recursively renders the view.
   *
   * Once the view is rendered:
   * * the {@link #element} becomes an HTML element out of {@link #template},
   * * the {@link #isRendered} flag is set `true`.
   *
   * **Note**: The children of the view:
   * * defined directly in the {@link #template}
   * * residing in collections created by the {@link #createCollection} method,
   * * and added by {@link #registerChild}
   * are also rendered in the process.
   *
   * In general, `render()` method is the right place to keep the code which refers to the
   * {@link #element} and should be executed at the very beginning of the view's life cycle.
   *
   * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
   * the view is rendered. To allow an early customization of the view (e.g. by its parent),
   * such references should be done in `render()`.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor() {
   * 		this.setTemplate( {
   * 			// ...
   * 		} );
   * 	},
   *
   * 	render() {
   * 		// View#element becomes available.
   * 		super.render();
   *
   * 		// The "scroll" listener depends on #element.
   * 		this.listenTo( window, 'scroll', () => {
   * 			// A reference to #element would render the #template and make it non-extendable.
   * 			if ( window.scrollY > 0 ) {
   * 				this.element.scrollLeft = 100;
   * 			} else {
   * 				this.element.scrollLeft = 0;
   * 			}
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView();
   *
   * // Let's customize the view before it gets rendered.
   * view.extendTemplate( {
   * 	attributes: {
   * 		class: [
   * 			'additional-class'
   * 		]
   * 	}
   * } );
   *
   * // Late rendering allows customization of the view.
   * view.render();
   * ```
   */
  render() {
    if (this.isRendered) {
      throw new CKEditorError("ui-view-render-already-rendered", this);
    }
    if (this.template) {
      this.element = this.template.render();
      this.registerChild(this.template.getViews());
    }
    this.isRendered = true;
  }
  /**
   * Recursively destroys the view instance and child views added by {@link #registerChild} and
   * residing in collections created by the {@link #createCollection}.
   *
   * Destruction disables all event listeners:
   * * created on the view, e.g. `view.on( 'event', () => {} )`,
   * * defined in the {@link #template} for DOM events.
   */
  destroy() {
    this.stopListening();
    this._viewCollections.map((c) => c.destroy());
    if (this.template && this.template._revertData) {
      this.template.revert(this.element);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/icon/iconview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css";
var IconView = class _IconView extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set("content", "");
    this.set("viewBox", "0 0 20 20");
    this.set("fillColor", "");
    this.set("isColorInherited", true);
    this.set("isVisible", true);
    this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          bind.if("isVisible", "ck-hidden", (value) => !value),
          // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          "ck-reset_all-excluded",
          // The class to remove the dynamic color inheritance is toggleable
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          bind.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: bind.to("viewBox")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this._updateXMLContent();
    this._colorFillPaths();
    this.on("change:content", () => {
      this._updateXMLContent();
      this._colorFillPaths();
    });
    this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  /**
   * Updates the {@link #element} with the value of {@link #content}.
   */
  _updateXMLContent() {
    if (this.content) {
      const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
      const svg = parsed.querySelector("svg");
      const viewBox = svg.getAttribute("viewBox");
      if (viewBox) {
        this.viewBox = viewBox;
      }
      for (const { name, value } of Array.from(svg.attributes)) {
        if (_IconView.presentationalAttributeNames.includes(name)) {
          this.element.setAttribute(name, value);
        }
      }
      while (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      while (svg.childNodes.length > 0) {
        this.element.appendChild(svg.childNodes[0]);
      }
    }
  }
  /**
   * Fills all child `path.ck-icon__fill` with the `#fillColor`.
   */
  _colorFillPaths() {
    if (this.fillColor) {
      this.element.querySelectorAll(".ck-icon__fill").forEach((path) => {
        path.style.fill = this.fillColor;
      });
    }
  }
};
IconView.presentationalAttributeNames = [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
];

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonlabelview.js
var ButtonLabelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    this.set({
      style: void 0,
      text: void 0,
      id: void 0
    });
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: bind.to("style"),
        id: bind.to("id")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css";
var ButtonView = class extends View {
  /**
   * Creates an instance of the button view class.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param labelView The instance of the button's label. If not provided, an instance of
   * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
   */
  constructor(locale, labelView = new ButtonLabelView()) {
    super(locale);
    this._focusDelayed = null;
    const bind = this.bindTemplate;
    const ariaLabelUid = uid();
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isVisible", true);
    this.set("isToggleable", false);
    this.set("keystroke", void 0);
    this.set("label", void 0);
    this.set("role", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.set("withKeystroke", false);
    this.children = this.createCollection();
    this.labelView = this._setupLabelView(labelView);
    this.iconView = new IconView();
    this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    });
    this.keystrokeView = this._createKeystrokeView();
    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const template = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          bind.to("isOn", (value) => value ? "ck-on" : "ck-off"),
          bind.if("withText", "ck-button_with-text"),
          bind.if("withKeystroke", "ck-button_with-keystroke")
        ],
        role: bind.to("role"),
        type: bind.to("type", (value) => value ? value : "button"),
        tabindex: bind.to("tabindex"),
        "aria-label": bind.to("ariaLabel"),
        "aria-labelledby": bind.to("ariaLabelledBy"),
        "aria-disabled": bind.if("isEnabled", true, (value) => !value),
        "aria-pressed": bind.to("isOn", (value) => this.isToggleable ? String(!!value) : false),
        "data-cke-tooltip-text": bind.to("_tooltipString"),
        "data-cke-tooltip-position": bind.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: bind.to((evt) => {
          if (this.isEnabled) {
            this.fire("execute");
          } else {
            evt.preventDefault();
          }
        })
      }
    };
    if (env_default.isSafari) {
      if (!this._focusDelayed) {
        this._focusDelayed = delay(() => this.focus(), 0);
      }
      template.on.mousedown = bind.to(() => {
        this._focusDelayed();
      });
      template.on.mouseup = bind.to(() => {
        this._focusDelayed.cancel();
      });
    }
    this.setTemplate(template);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this.icon) {
      this.iconView.bind("content").to(this, "icon");
      this.children.add(this.iconView);
    }
    this.children.add(this.labelView);
    if (this.withKeystroke && this.keystroke) {
      this.children.add(this.keystrokeView);
    }
  }
  /**
   * Focuses the {@link #element} of the button.
   */
  focus() {
    this.element.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._focusDelayed) {
      this._focusDelayed.cancel();
    }
    super.destroy();
  }
  /**
   * Binds the label view instance it with button attributes.
   */
  _setupLabelView(labelView) {
    labelView.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
    return labelView;
  }
  /**
   * Creates a view that displays a keystroke next to a {@link #labelView label }
   * and binds it with button attributes.
   */
  _createKeystrokeView() {
    const keystrokeView = new View();
    keystrokeView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (text) => getEnvKeystrokeText(text))
        }
      ]
    });
    return keystrokeView;
  }
  /**
   * Gets the text for the tooltip from the combination of
   * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
   *
   * @see #tooltip
   * @see #_tooltipString
   * @param tooltip Button tooltip.
   * @param label Button label.
   * @param keystroke Button keystroke.
   */
  _getTooltipString(tooltip, label, keystroke) {
    if (tooltip) {
      if (typeof tooltip == "string") {
        return tooltip;
      } else {
        if (keystroke) {
          keystroke = getEnvKeystrokeText(keystroke);
        }
        if (tooltip instanceof Function) {
          return tooltip(label, keystroke);
        } else {
          return `${label}${keystroke ? ` (${keystroke})` : ""}`;
        }
      }
    }
    return "";
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css";

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js
import checkIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-tile-check.svg";

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css";

// node_modules/color-parse/index.mjs
var import_color_name = __toESM(require_color_name(), 1);

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/utils.js
var convert = __toESM(require_color_convert());

// node_modules/@ckeditor/ckeditor5-ui/src/label/labelview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css";
var LabelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("text", void 0);
    this.set("for", void 0);
    this.id = `ck-editor__label_${uid()}`;
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "label",
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: bind.to("for")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css";
var LabeledFieldView = class extends View {
  /**
   * Creates an instance of the labeled field view class using a provided creator function
   * that provides the view to be labeled.
   *
   * @param locale The locale instance.
   * @param viewCreator A function that returns a {@link module:ui/view~View}
   * that will be labeled. The following arguments are passed to the creator function:
   *
   * * an instance of the `LabeledFieldView` to allow binding observable properties,
   * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
   * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
   */
  constructor(locale, viewCreator) {
    super(locale);
    const viewUid = `ck-labeled-field-view-${uid()}`;
    const statusUid = `ck-labeled-field-view-status-${uid()}`;
    this.fieldView = viewCreator(this, viewUid, statusUid);
    this.set("label", void 0);
    this.set("isEnabled", true);
    this.set("isEmpty", true);
    this.set("isFocused", false);
    this.set("errorText", null);
    this.set("infoText", null);
    this.set("class", void 0);
    this.set("placeholder", void 0);
    this.labelView = this._createLabelView(viewUid);
    this.statusView = this._createStatusView(statusUid);
    this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]);
    this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isEmpty", "ck-labeled-field-view_empty"),
          bind.if("isFocused", "ck-labeled-field-view_focused"),
          bind.if("placeholder", "ck-labeled-field-view_placeholder"),
          bind.if("errorText", "ck-error")
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__input-wrapper"
            ]
          },
          children: this.fieldWrapperChildren
        },
        this.statusView
      ]
    });
  }
  /**
   * Creates label view class instance and bind with view.
   *
   * @param id Unique id to set as labelView#for attribute.
   */
  _createLabelView(id) {
    const labelView = new LabelView(this.locale);
    labelView.for = id;
    labelView.bind("text").to(this, "label");
    return labelView;
  }
  /**
   * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
   * next to the {@link #fieldView}. See {@link #_statusText}.
   *
   * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
   * `aria-describedby` attribute.
   */
  _createStatusView(statusUid) {
    const statusView = new View(this.locale);
    const bind = this.bindTemplate;
    statusView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view__status",
          bind.if("errorText", "ck-labeled-field-view__status_error"),
          bind.if("_statusText", "ck-hidden", (value) => !value)
        ],
        id: statusUid,
        role: bind.if("errorText", "alert")
      },
      children: [
        {
          text: bind.to("_statusText")
        }
      ]
    });
    return statusView;
  }
  /**
   * Focuses the {@link #fieldView}.
   */
  focus(direction) {
    this.fieldView.focus(direction);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/input/inputbase.js
var InputBase = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("value", void 0);
    this.set("id", void 0);
    this.set("placeholder", void 0);
    this.set("isReadOnly", false);
    this.set("hasError", false);
    this.set("ariaDescribedById", void 0);
    this.focusTracker = new FocusTracker();
    this.bind("isFocused").to(this.focusTracker);
    this.set("isEmpty", true);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck",
          "ck-input",
          bind.if("isFocused", "ck-input_focused"),
          bind.if("isEmpty", "ck-input-text_empty"),
          bind.if("hasError", "ck-error")
        ],
        id: bind.to("id"),
        placeholder: bind.to("placeholder"),
        readonly: bind.to("isReadOnly"),
        "aria-invalid": bind.if("hasError", true),
        "aria-describedby": bind.to("ariaDescribedById")
      },
      on: {
        input: bind.to((...args) => {
          this.fire("input", ...args);
          this._updateIsEmpty();
        }),
        change: bind.to(this._updateIsEmpty.bind(this))
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.element);
    this._setDomElementValue(this.value);
    this._updateIsEmpty();
    this.on("change:value", (evt, name, value) => {
      this._setDomElementValue(value);
      this._updateIsEmpty();
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  /**
   * Moves the focus to the input and selects the value.
   */
  select() {
    this.element.select();
  }
  /**
   * Focuses the input.
   */
  focus() {
    this.element.focus();
  }
  /**
   * Resets the value of the input
   */
  reset() {
    this.value = this.element.value = "";
    this._updateIsEmpty();
  }
  /**
   * Updates the {@link #isEmpty} property value on demand.
   */
  _updateIsEmpty() {
    this.isEmpty = isInputElementEmpty(this.element);
  }
  /**
   * Sets the `value` property of the {@link #element DOM element} on demand.
   */
  _setDomElementValue(value) {
    this.element.value = !value && value !== 0 ? "" : value;
  }
};
function isInputElementEmpty(domElement) {
  return !domElement.value;
}

// node_modules/@ckeditor/ckeditor5-ui/src/input/inputview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/input/input.css";
var InputView = class extends InputBase {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("inputMode", "text");
    const bind = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        inputmode: bind.to("inputMode")
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js
var InputTextView = class extends InputView {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.extendTemplate({
      attributes: {
        type: "text",
        class: [
          "ck-input-text"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/textarea/textareaview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/input/input.css";
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/textarea/textarea.css";

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css";
var DropdownView = class _DropdownView extends View {
  /**
   * Creates an instance of the dropdown.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(locale, buttonView, panelView) {
    super(locale);
    const bind = this.bindTemplate;
    this.buttonView = buttonView;
    this.panelView = panelView;
    this.set("isOpen", false);
    this.set("isEnabled", true);
    this.set("class", void 0);
    this.set("id", void 0);
    this.set("panelPosition", "auto");
    this.panelView.bind("isVisible").to(this, "isOpen");
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value)
        ],
        id: bind.to("id"),
        "aria-describedby": bind.to("ariaDescribedById")
      },
      children: [
        buttonView,
        panelView
      ]
    });
    buttonView.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown__button"
        ],
        "data-cke-tooltip-disabled": bind.to("isOpen")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    });
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      if (this.panelPosition === "auto") {
        const optimalPanelPosition = _DropdownView._getOptimalPosition({
          element: this.panelView.element,
          target: this.buttonView.element,
          fitInViewport: true,
          positions: this._panelPositions
        });
        this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._panelPositions[0].name;
      } else {
        this.panelView.position = this.panelPosition;
      }
    });
    this.keystrokes.listenTo(this.element);
    const closeDropdown = (data, cancel) => {
      if (this.isOpen) {
        this.isOpen = false;
        cancel();
      }
    };
    this.keystrokes.set("arrowdown", (data, cancel) => {
      if (this.buttonView.isEnabled && !this.isOpen) {
        this.isOpen = true;
        cancel();
      }
    });
    this.keystrokes.set("arrowright", (data, cancel) => {
      if (this.isOpen) {
        cancel();
      }
    });
    this.keystrokes.set("arrowleft", closeDropdown);
    this.keystrokes.set("esc", closeDropdown);
  }
  /**
   * Focuses the {@link #buttonView}.
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Returns {@link #panelView panel} positions to be used by the
   * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
   * utility considering the direction of the language the UI of the editor is displayed in.
   */
  get _panelPositions() {
    const { south, north, southEast, southWest, northEast, northWest, southMiddleEast, southMiddleWest, northMiddleEast, northMiddleWest } = _DropdownView.defaultPanelPositions;
    if (this.locale.uiLanguageDirection !== "rtl") {
      return [
        southEast,
        southWest,
        southMiddleEast,
        southMiddleWest,
        south,
        northEast,
        northWest,
        northMiddleEast,
        northMiddleWest,
        north
      ];
    } else {
      return [
        southWest,
        southEast,
        southMiddleWest,
        southMiddleEast,
        south,
        northWest,
        northEast,
        northMiddleWest,
        northMiddleEast,
        north
      ];
    }
  }
};
DropdownView.defaultPanelPositions = {
  south: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "s"
    };
  },
  southEast: (buttonRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: "se"
    };
  },
  southWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "sw"
    };
  },
  southMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "sme"
    };
  },
  southMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "smw"
    };
  },
  north: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "n"
    };
  },
  northEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: "ne"
    };
  },
  northWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "nw"
    };
  },
  northMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "nme"
    };
  },
  northMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "nmw"
    };
  }
};
DropdownView._getOptimalPosition = getOptimalPosition;

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js
import dropdownArrowIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";

// node_modules/@ckeditor/ckeditor5-ui/src/focuscycler.js
var FocusCycler = class extends EmitterMixin() {
  /**
   * Creates an instance of the focus cycler utility.
   *
   * @param options Configuration options.
   */
  constructor(options) {
    super();
    this.focusables = options.focusables;
    this.focusTracker = options.focusTracker;
    this.keystrokeHandler = options.keystrokeHandler;
    this.actions = options.actions;
    if (options.actions && options.keystrokeHandler) {
      for (const methodName in options.actions) {
        let actions = options.actions[methodName];
        if (typeof actions == "string") {
          actions = [actions];
        }
        for (const keystroke of actions) {
          options.keystrokeHandler.set(keystroke, (data, cancel) => {
            this[methodName]();
            cancel();
          });
        }
      }
    }
    this.on("forwardCycle", () => this.focusFirst(), { priority: "low" });
    this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
  }
  /**
   * Returns the first focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get first() {
    return this.focusables.find(isFocusable) || null;
  }
  /**
   * Returns the last focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get last() {
    return this.focusables.filter(isFocusable).slice(-1)[0] || null;
  }
  /**
   * Returns the next focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get next() {
    return this._getFocusableItem(1);
  }
  /**
   * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get previous() {
    return this._getFocusableItem(-1);
  }
  /**
   * An index of the view in the {@link #focusables} which is focused according
   * to {@link #focusTracker}. Returns `null` when there is no such view.
   */
  get current() {
    let index = null;
    if (this.focusTracker.focusedElement === null) {
      return null;
    }
    this.focusables.find((view, viewIndex) => {
      const focused = view.element === this.focusTracker.focusedElement;
      if (focused) {
        index = viewIndex;
      }
      return focused;
    });
    return index;
  }
  /**
   * Focuses the {@link #first} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusFirst() {
    this._focus(this.first, 1);
  }
  /**
   * Focuses the {@link #last} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusLast() {
    this._focus(this.last, -1);
  }
  /**
   * Focuses the {@link #next} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusNext() {
    const next = this.next;
    if (next && this.focusables.getIndex(next) === this.current) {
      return;
    }
    if (next === this.first) {
      this.fire("forwardCycle");
    } else {
      this._focus(next, 1);
    }
  }
  /**
   * Focuses the {@link #previous} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusPrevious() {
    const previous = this.previous;
    if (previous && this.focusables.getIndex(previous) === this.current) {
      return;
    }
    if (previous === this.last) {
      this.fire("backwardCycle");
    } else {
      this._focus(previous, -1);
    }
  }
  /**
   * Focuses the given view if it exists.
   *
   * @param view The view to be focused
   * @param direction The direction of the focus if the view has focusable children.
   * @returns
   */
  _focus(view, direction) {
    if (view) {
      view.focus(direction);
    }
  }
  /**
   * Returns the next or previous focusable view in {@link #focusables} with respect
   * to {@link #current}.
   *
   * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
   */
  _getFocusableItem(step) {
    const current = this.current;
    const collectionLength = this.focusables.length;
    if (!collectionLength) {
      return null;
    }
    if (current === null) {
      return this[step === 1 ? "first" : "last"];
    }
    let index = (current + collectionLength + step) % collectionLength;
    do {
      const view = this.focusables.get(index);
      if (isFocusable(view)) {
        return view;
      }
      index = (index + collectionLength + step) % collectionLength;
    } while (index !== current);
    return null;
  }
};
function isFocusable(view) {
  return !!("focus" in view && isVisible(view.element));
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css";
var { threeVerticalDots } = icons;
var NESTED_TOOLBAR_ICONS = {
  alignLeft: icons.alignLeft,
  bold: icons.bold,
  importExport: icons.importExport,
  paragraph: icons.paragraph,
  plus: icons.plus,
  text: icons.text,
  threeVerticalDots: icons.threeVerticalDots,
  pilcrow: icons.pilcrow,
  dragIndicator: icons.dragIndicator
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css";

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js
import dropdownArrowIcon2 from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css";

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/utils.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css";
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/listdropdown.css";

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/utils.js
var createLabeledInputText = (labeledFieldView, viewUid, statusUid) => {
  const inputView = new InputTextView(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
};

// node_modules/vanilla-colorful/lib/utils/math.js
var clamp = (number, min = 0, max = 1) => {
  return number > max ? max : number < min ? min : number;
};
var round = (number, digits = 0, base = Math.pow(10, digits)) => {
  return Math.round(base * number) / base;
};

// node_modules/vanilla-colorful/lib/utils/convert.js
var angleUnits = {
  grad: 360 / 400,
  turn: 360,
  rad: 360 / (Math.PI * 2)
};
var hexToHsva = (hex) => rgbaToHsva(hexToRgba(hex));
var hexToRgba = (hex) => {
  if (hex[0] === "#")
    hex = hex.substring(1);
  if (hex.length < 6) {
    return {
      r: parseInt(hex[0] + hex[0], 16),
      g: parseInt(hex[1] + hex[1], 16),
      b: parseInt(hex[2] + hex[2], 16),
      a: hex.length === 4 ? round(parseInt(hex[3] + hex[3], 16) / 255, 2) : 1
    };
  }
  return {
    r: parseInt(hex.substring(0, 2), 16),
    g: parseInt(hex.substring(2, 4), 16),
    b: parseInt(hex.substring(4, 6), 16),
    a: hex.length === 8 ? round(parseInt(hex.substring(6, 8), 16) / 255, 2) : 1
  };
};
var hsvaToHex = (hsva) => rgbaToHex(hsvaToRgba(hsva));
var hsvaToHsla = ({ h, s, v, a }) => {
  const hh = (200 - s) * v / 100;
  return {
    h: round(h),
    s: round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
    l: round(hh / 2),
    a: round(a, 2)
  };
};
var hsvaToHslString = (hsva) => {
  const { h, s, l } = hsvaToHsla(hsva);
  return `hsl(${h}, ${s}%, ${l}%)`;
};
var hsvaToRgba = ({ h, s, v, a }) => {
  h = h / 360 * 6;
  s = s / 100;
  v = v / 100;
  const hh = Math.floor(h), b = v * (1 - s), c = v * (1 - (h - hh) * s), d = v * (1 - (1 - h + hh) * s), module = hh % 6;
  return {
    r: round([v, c, b, b, d, v][module] * 255),
    g: round([d, v, v, c, b, b][module] * 255),
    b: round([b, b, d, v, v, c][module] * 255),
    a: round(a, 2)
  };
};
var format = (number) => {
  const hex = number.toString(16);
  return hex.length < 2 ? "0" + hex : hex;
};
var rgbaToHex = ({ r, g, b, a }) => {
  const alphaHex = a < 1 ? format(round(a * 255)) : "";
  return "#" + format(r) + format(g) + format(b) + alphaHex;
};
var rgbaToHsva = ({ r, g, b, a }) => {
  const max = Math.max(r, g, b);
  const delta = max - Math.min(r, g, b);
  const hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
  return {
    h: round(60 * (hh < 0 ? hh + 6 : hh)),
    s: round(max ? delta / max * 100 : 0),
    v: round(max / 255 * 100),
    a
  };
};

// node_modules/vanilla-colorful/lib/utils/compare.js
var equalColorObjects = (first2, second) => {
  if (first2 === second)
    return true;
  for (const prop in first2) {
    if (first2[prop] !== second[prop])
      return false;
  }
  return true;
};
var equalHex = (first2, second) => {
  if (first2.toLowerCase() === second.toLowerCase())
    return true;
  return equalColorObjects(hexToRgba(first2), hexToRgba(second));
};

// node_modules/vanilla-colorful/lib/utils/dom.js
var cache = {};
var tpl = (html) => {
  let template = cache[html];
  if (!template) {
    template = document.createElement("template");
    template.innerHTML = html;
    cache[html] = template;
  }
  return template;
};
var fire = (target, type, detail) => {
  target.dispatchEvent(new CustomEvent(type, {
    bubbles: true,
    detail
  }));
};

// node_modules/vanilla-colorful/lib/components/slider.js
var hasTouched = false;
var isTouch = (e) => "touches" in e;
var isValid = (event) => {
  if (hasTouched && !isTouch(event))
    return false;
  if (!hasTouched)
    hasTouched = isTouch(event);
  return true;
};
var pointerMove = (target, event) => {
  const pointer = isTouch(event) ? event.touches[0] : event;
  const rect = target.el.getBoundingClientRect();
  fire(target.el, "move", target.getMove({
    x: clamp((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),
    y: clamp((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height)
  }));
};
var keyMove = (target, event) => {
  const keyCode = event.keyCode;
  if (keyCode > 40 || target.xy && keyCode < 37 || keyCode < 33)
    return;
  event.preventDefault();
  fire(target.el, "move", target.getMove({
    x: keyCode === 39 ? 0.01 : keyCode === 37 ? -0.01 : keyCode === 34 ? 0.05 : keyCode === 33 ? -0.05 : keyCode === 35 ? 1 : keyCode === 36 ? -1 : 0,
    y: keyCode === 40 ? 0.01 : keyCode === 38 ? -0.01 : 0
  }, true));
};
var Slider = class {
  constructor(root, part, aria, xy) {
    const template = tpl(`<div role="slider" tabindex="0" part="${part}" ${aria}><div part="${part}-pointer"></div></div>`);
    root.appendChild(template.content.cloneNode(true));
    const el = root.querySelector(`[part=${part}]`);
    el.addEventListener("mousedown", this);
    el.addEventListener("touchstart", this);
    el.addEventListener("keydown", this);
    this.el = el;
    this.xy = xy;
    this.nodes = [el.firstChild, el];
  }
  set dragging(state) {
    const toggleEvent = state ? document.addEventListener : document.removeEventListener;
    toggleEvent(hasTouched ? "touchmove" : "mousemove", this);
    toggleEvent(hasTouched ? "touchend" : "mouseup", this);
  }
  handleEvent(event) {
    switch (event.type) {
      case "mousedown":
      case "touchstart":
        event.preventDefault();
        if (!isValid(event) || !hasTouched && event.button != 0)
          return;
        this.el.focus();
        pointerMove(this, event);
        this.dragging = true;
        break;
      case "mousemove":
      case "touchmove":
        event.preventDefault();
        pointerMove(this, event);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = false;
        break;
      case "keydown":
        keyMove(this, event);
        break;
    }
  }
  style(styles) {
    styles.forEach((style, i) => {
      for (const p in style) {
        this.nodes[i].style.setProperty(p, style[p]);
      }
    });
  }
};

// node_modules/vanilla-colorful/lib/components/hue.js
var Hue = class extends Slider {
  constructor(root) {
    super(root, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
  }
  update({ h }) {
    this.h = h;
    this.style([
      {
        left: `${h / 360 * 100}%`,
        color: hsvaToHslString({ h, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuenow", `${round(h)}`);
  }
  getMove(offset, key) {
    return { h: key ? clamp(this.h + offset.x * 360, 0, 360) : 360 * offset.x };
  }
};

// node_modules/vanilla-colorful/lib/components/saturation.js
var Saturation = class extends Slider {
  constructor(root) {
    super(root, "saturation", 'aria-label="Color"', true);
  }
  update(hsva) {
    this.hsva = hsva;
    this.style([
      {
        top: `${100 - hsva.v}%`,
        left: `${hsva.s}%`,
        color: hsvaToHslString(hsva)
      },
      {
        "background-color": hsvaToHslString({ h: hsva.h, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuetext", `Saturation ${round(hsva.s)}%, Brightness ${round(hsva.v)}%`);
  }
  getMove(offset, key) {
    return {
      s: key ? clamp(this.hsva.s + offset.x * 100, 0, 100) : offset.x * 100,
      v: key ? clamp(this.hsva.v - offset.y * 100, 0, 100) : Math.round(100 - offset.y * 100)
    };
  }
};

// node_modules/vanilla-colorful/lib/styles/color-picker.js
var color_picker_default = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;

// node_modules/vanilla-colorful/lib/styles/hue.js
var hue_default = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;

// node_modules/vanilla-colorful/lib/styles/saturation.js
var saturation_default = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;

// node_modules/vanilla-colorful/lib/components/color-picker.js
var $isSame = Symbol("same");
var $color = Symbol("color");
var $hsva = Symbol("hsva");
var $update = Symbol("update");
var $parts = Symbol("parts");
var $css = Symbol("css");
var $sliders = Symbol("sliders");
var ColorPicker = class extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [$css]() {
    return [color_picker_default, hue_default, saturation_default];
  }
  get [$sliders]() {
    return [Saturation, Hue];
  }
  get color() {
    return this[$color];
  }
  set color(newColor) {
    if (!this[$isSame](newColor)) {
      const newHsva = this.colorModel.toHsva(newColor);
      this[$update](newHsva);
      this[$color] = newColor;
    }
  }
  constructor() {
    super();
    const template = tpl(`<style>${this[$css].join("")}</style>`);
    const root = this.attachShadow({ mode: "open" });
    root.appendChild(template.content.cloneNode(true));
    root.addEventListener("move", this);
    this[$parts] = this[$sliders].map((slider) => new slider(root));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const value = this.color;
      delete this["color"];
      this.color = value;
    } else if (!this.color) {
      this.color = this.colorModel.defaultColor;
    }
  }
  attributeChangedCallback(_attr, _oldVal, newVal) {
    const color = this.colorModel.fromAttr(newVal);
    if (!this[$isSame](color)) {
      this.color = color;
    }
  }
  handleEvent(event) {
    const oldHsva = this[$hsva];
    const newHsva = { ...oldHsva, ...event.detail };
    this[$update](newHsva);
    let newColor;
    if (!equalColorObjects(newHsva, oldHsva) && !this[$isSame](newColor = this.colorModel.fromHsva(newHsva))) {
      this[$color] = newColor;
      fire(this, "color-changed", { value: newColor });
    }
  }
  [$isSame](color) {
    return this.color && this.colorModel.equal(color, this.color);
  }
  [$update](hsva) {
    this[$hsva] = hsva;
    this[$parts].forEach((part) => part.update(hsva));
  }
};

// node_modules/vanilla-colorful/lib/entrypoints/hex.js
var colorModel = {
  defaultColor: "#000",
  toHsva: hexToHsva,
  fromHsva: ({ h, s, v }) => hsvaToHex({ h, s, v, a: 1 }),
  equal: equalHex,
  fromAttr: (color) => color
};
var HexBase = class extends ColorPicker {
  get colorModel() {
    return colorModel;
  }
};

// node_modules/vanilla-colorful/hex-color-picker.js
var HexColorPicker = class extends HexBase {
};
customElements.define("hex-color-picker", HexColorPicker);

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/colorpickerview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css";

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/documentcolorcollection.js
var DocumentColorCollection = class extends ObservableMixin(Collection) {
  constructor(options) {
    super(options);
    this.set("isEmpty", true);
    this.on("change", () => {
      this.set("isEmpty", this.length === 0);
    });
  }
  /**
   * Adds a color to the document color collection.
   *
   * This method ensures that no color duplicates are inserted (compared using
   * the color value of the {@link module:ui/colorgrid/colorgridview~ColorDefinition}).
   *
   * If the item does not have an ID, it will be automatically generated and set on the item.
   *
   * @param index The position of the item in the collection. The item is pushed to the collection when `index` is not specified.
   * @fires add
   * @fires change
   */
  add(item, index) {
    if (this.find((element) => element.color === item.color)) {
      return this;
    }
    return super.add(item, index);
  }
  /**
   * Checks if an object with given colors is present in the document color collection.
   */
  hasColor(color) {
    return !!this.find((item) => item.color === color);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorgridsfragmentview.js
import removeButtonIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-core/theme/icons/eraser.svg";
import colorPaletteIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-palette.svg";

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorpickerfragmentview.js
import checkButtonIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-core/theme/icons/check.svg";
import cancelButtonIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-core/theme/icons/cancel.svg";

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorselectorview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorselector/colorselector.css";

// node_modules/@ckeditor/ckeditor5-ui/src/componentfactory.js
var ComponentFactory = class {
  /**
   * Creates an instance of the factory.
   *
   * @param editor The editor instance.
   */
  constructor(editor) {
    this._components = /* @__PURE__ */ new Map();
    this.editor = editor;
  }
  /**
   * Returns an iterator of registered component names. Names are returned in lower case.
   */
  *names() {
    for (const value of this._components.values()) {
      yield value.originalName;
    }
  }
  /**
   * Registers a component factory function that will be used by the
   * {@link #create create} method and called with the
   * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
   * allowing localization of the {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @param callback The callback that returns the component.
   */
  add(name, callback) {
    this._components.set(getNormalized(name), { callback, originalName: name });
  }
  /**
   * Creates an instance of a component registered in the factory under a specific name.
   *
   * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
   * the previously {@link #add added} factory function, allowing localization of the
   * {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @returns The instantiated component view.
   */
  create(name) {
    if (!this.has(name)) {
      throw new CKEditorError("componentfactory-item-missing", this, { name });
    }
    return this._components.get(getNormalized(name)).callback(this.editor.locale);
  }
  /**
   * Checks if a component of a given name is registered in the factory.
   *
   * @param name The name of the component.
   */
  has(name) {
    return this._components.has(getNormalized(name));
  }
};
function getNormalized(name) {
  return String(name).toLowerCase();
}

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css";
var toPx = toUnit("px");
var defaultLimiterElement = global_default.document.body;
var POSITION_OFF_SCREEN = {
  top: -99999,
  left: -99999,
  name: "arrowless",
  config: {
    withArrow: false
  }
};
var BalloonPanelView = class _BalloonPanelView extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("position", "arrow_nw");
    this.set("isVisible", false);
    this.set("withArrow", true);
    this.set("class", void 0);
    this._pinWhenIsVisibleCallback = null;
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-panel",
          bind.to("position", (value) => `ck-balloon-panel_${value}`),
          bind.if("isVisible", "ck-balloon-panel_visible"),
          bind.if("withArrow", "ck-balloon-panel_with-arrow"),
          bind.to("class")
        ],
        style: {
          top: bind.to("top", toPx),
          left: bind.to("left", toPx)
        }
      },
      children: this.content
    });
  }
  /**
   * Shows the panel.
   *
   * See {@link #isVisible}.
   */
  show() {
    this.isVisible = true;
  }
  /**
   * Hides the panel.
   *
   * See {@link #isVisible}.
   */
  hide() {
    this.isVisible = false;
  }
  /**
   * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
   * smart positioning heuristics that chooses from available positions to make sure the panel
   * is visible to the user i.e. within the limits of the viewport.
   *
   * This method accepts configuration {@link module:utils/dom/position~Options options}
   * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Attach the panel to an element with the "target" id DOM.
   * panel.attachTo( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * **Note**: Attaching the panel will also automatically {@link #show} it.
   *
   * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
   * See the {@link #pin} method for a more permanent positioning strategy.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  attachTo(options) {
    this.show();
    const defaultPositions = _BalloonPanelView.defaultPositions;
    const positionOptions = Object.assign({}, {
      element: this.element,
      positions: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthMiddleWest,
        defaultPositions.southArrowNorthMiddleEast,
        defaultPositions.southArrowNorthWest,
        defaultPositions.southArrowNorthEast,
        defaultPositions.northArrowSouth,
        defaultPositions.northArrowSouthMiddleWest,
        defaultPositions.northArrowSouthMiddleEast,
        defaultPositions.northArrowSouthWest,
        defaultPositions.northArrowSouthEast,
        defaultPositions.viewportStickyNorth
      ],
      limiter: defaultLimiterElement,
      fitInViewport: true
    }, options);
    const optimalPosition = _BalloonPanelView._getOptimalPosition(positionOptions) || POSITION_OFF_SCREEN;
    const left = parseInt(optimalPosition.left);
    const top = parseInt(optimalPosition.top);
    const position = optimalPosition.name;
    const config = optimalPosition.config || {};
    const { withArrow = true } = config;
    this.top = top;
    this.left = left;
    this.position = position;
    this.withArrow = withArrow;
  }
  /**
   * Works the same way as the {@link #attachTo} method except that the position of the panel is
   * continuously updated when:
   *
   * * any ancestor of the {@link module:utils/dom/position~Options#target}
   * or {@link module:utils/dom/position~Options#limiter} is scrolled,
   * * the browser window gets resized or scrolled.
   *
   * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
   * and is immune to the changing environment.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Pin the panel to an element with the "target" id DOM.
   * panel.pin( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * To leave the pinned state, use the {@link #unpin} method.
   *
   * **Note**: Pinning the panel will also automatically {@link #show} it.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  pin(options) {
    this.unpin();
    this._pinWhenIsVisibleCallback = () => {
      if (this.isVisible) {
        this._startPinning(options);
      } else {
        this._stopPinning();
      }
    };
    this._startPinning(options);
    this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
  }
  /**
   * Stops pinning the panel, as set up by {@link #pin}.
   */
  unpin() {
    if (this._pinWhenIsVisibleCallback) {
      this._stopPinning();
      this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
      this._pinWhenIsVisibleCallback = null;
      this.hide();
    }
  }
  /**
   * Starts managing the pinned state of the panel. See {@link #pin}.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   */
  _startPinning(options) {
    this.attachTo(options);
    const targetElement = getDomElement(options.target);
    const limiterElement = options.limiter ? getDomElement(options.limiter) : defaultLimiterElement;
    this.listenTo(global_default.document, "scroll", (evt, domEvt) => {
      const scrollTarget = domEvt.target;
      const isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement);
      const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement);
      if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
        this.attachTo(options);
      }
    }, { useCapture: true });
    this.listenTo(global_default.window, "resize", () => {
      this.attachTo(options);
    });
  }
  /**
   * Stops managing the pinned state of the panel. See {@link #pin}.
   */
  _stopPinning() {
    this.stopListening(global_default.document, "scroll");
    this.stopListening(global_default.window, "resize");
  }
};
BalloonPanelView.arrowSideOffset = 25;
BalloonPanelView.arrowHeightOffset = 10;
BalloonPanelView.stickyVerticalOffset = 20;
BalloonPanelView._getOptimalPosition = getOptimalPosition;
BalloonPanelView.defaultPositions = generatePositions();
function getDomElement(object) {
  if (isElement_default(object)) {
    return object;
  }
  if (isRange(object)) {
    return object.commonAncestorContainer;
  }
  if (typeof object == "function") {
    return getDomElement(object());
  }
  return null;
}
function generatePositions(options = {}) {
  const { sideOffset = BalloonPanelView.arrowSideOffset, heightOffset = BalloonPanelView.arrowHeightOffset, stickyVerticalOffset = BalloonPanelView.stickyVerticalOffset, config } = options;
  return {
    // ------- North west
    northWestArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - sideOffset,
      name: "arrow_sw",
      ...config && { config }
    }),
    northWestArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && { config }
    }),
    northWestArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width / 2,
      name: "arrow_s",
      ...config && { config }
    }),
    northWestArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && { config }
    }),
    northWestArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && { config }
    }),
    // ------- North
    northArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - sideOffset,
      name: "arrow_sw",
      ...config && { config }
    }),
    northArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && { config }
    }),
    northArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: "arrow_s",
      ...config && { config }
    }),
    northArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && { config }
    }),
    northArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && { config }
    }),
    // ------- North east
    northEastArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - sideOffset,
      name: "arrow_sw",
      ...config && { config }
    }),
    northEastArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && { config }
    }),
    northEastArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width / 2,
      name: "arrow_s",
      ...config && { config }
    }),
    northEastArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && { config }
    }),
    northEastArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && { config }
    }),
    // ------- South west
    southWestArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - sideOffset,
      name: "arrow_nw",
      ...config && { config }
    }),
    southWestArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && { config }
    }),
    southWestArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width / 2,
      name: "arrow_n",
      ...config && { config }
    }),
    southWestArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && { config }
    }),
    southWestArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && { config }
    }),
    // ------- South
    southArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - sideOffset,
      name: "arrow_nw",
      ...config && { config }
    }),
    southArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && { config }
    }),
    southArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: "arrow_n",
      ...config && { config }
    }),
    southArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && { config }
    }),
    southArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && { config }
    }),
    // ------- South east
    southEastArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - sideOffset,
      name: "arrow_nw",
      ...config && { config }
    }),
    southEastArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && { config }
    }),
    southEastArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width / 2,
      name: "arrow_n",
      ...config && { config }
    }),
    southEastArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && { config }
    }),
    southEastArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && { config }
    }),
    // ------- West
    westArrowEast: (targetRect, balloonRect) => ({
      top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
      left: targetRect.left - balloonRect.width - heightOffset,
      name: "arrow_e",
      ...config && { config }
    }),
    // ------- East
    eastArrowWest: (targetRect, balloonRect) => ({
      top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
      left: targetRect.right + heightOffset,
      name: "arrow_w",
      ...config && { config }
    }),
    // ------- Sticky
    viewportStickyNorth: (targetRect, balloonRect, viewportRect, limiterRect) => {
      const boundaryRect = limiterRect || viewportRect;
      if (!targetRect.getIntersection(boundaryRect)) {
        return null;
      }
      if (boundaryRect.height - targetRect.height > stickyVerticalOffset) {
        return null;
      }
      return {
        top: boundaryRect.top + stickyVerticalOffset,
        left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
        name: "arrowless",
        config: {
          withArrow: false,
          ...config
        }
      };
    }
  };
  function getNorthTop(targetRect, balloonRect) {
    return targetRect.top - balloonRect.height - heightOffset;
  }
  function getSouthTop(targetRect) {
    return targetRect.bottom + heightOffset;
  }
}

// node_modules/@ckeditor/ckeditor5-ui/src/tooltipmanager.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css";
var BALLOON_CLASS = "ck-tooltip";
var TooltipManager = class _TooltipManager extends DomEmitterMixin() {
  /**
   * Creates an instance of the tooltip manager.
   */
  constructor(editor) {
    super();
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    this._resizeObserver = null;
    _TooltipManager._editors.add(editor);
    if (_TooltipManager._instance) {
      return _TooltipManager._instance;
    }
    _TooltipManager._instance = this;
    this.tooltipTextView = new View(editor.locale);
    this.tooltipTextView.set("text", "");
    this.tooltipTextView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-tooltip__text"
        ]
      },
      children: [
        {
          text: this.tooltipTextView.bindTemplate.to("text")
        }
      ]
    });
    this.balloonPanelView = new BalloonPanelView(editor.locale);
    this.balloonPanelView.class = BALLOON_CLASS;
    this.balloonPanelView.content.add(this.tooltipTextView);
    this._pinTooltipDebounced = debounce_default(this._pinTooltip, 600);
    this.listenTo(global_default.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "scroll", this._onScroll.bind(this), { useCapture: true });
    this._watchdogExcluded = true;
  }
  /**
   * Destroys the tooltip manager.
   *
   * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
   *
   * @param editor The editor the manager was created for.
   */
  destroy(editor) {
    const editorBodyViewCollection = editor.ui.view && editor.ui.view.body;
    _TooltipManager._editors.delete(editor);
    this.stopListening(editor.ui);
    if (editorBodyViewCollection && editorBodyViewCollection.has(this.balloonPanelView)) {
      editorBodyViewCollection.remove(this.balloonPanelView);
    }
    if (!_TooltipManager._editors.size) {
      this._unpinTooltip();
      this.balloonPanelView.destroy();
      this.stopListening();
      _TooltipManager._instance = null;
    }
  }
  /**
   * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
   * name.
   *
   * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
   * @returns Positioning functions to be used by the {@link #balloonPanelView}.
   */
  static getPositioningFunctions(position) {
    const defaultPositions = _TooltipManager.defaultBalloonPositions;
    return {
      // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
      s: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthEast,
        defaultPositions.southArrowNorthWest
      ],
      n: [defaultPositions.northArrowSouth],
      e: [defaultPositions.eastArrowWest],
      w: [defaultPositions.westArrowEast],
      sw: [defaultPositions.southArrowNorthEast],
      se: [defaultPositions.southArrowNorthWest]
    }[position];
  }
  /**
   * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onEnterOrFocus(evt, { target }) {
    const elementWithTooltipAttribute = getDescendantWithTooltip(target);
    if (!elementWithTooltipAttribute) {
      return;
    }
    if (elementWithTooltipAttribute === this._currentElementWithTooltip) {
      return;
    }
    this._unpinTooltip();
    this._pinTooltipDebounced(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
  }
  /**
   * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onLeaveOrBlur(evt, { target, relatedTarget }) {
    if (evt.name === "mouseleave") {
      if (!isElement_default(target)) {
        return;
      }
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      const descendantWithTooltip = getDescendantWithTooltip(target);
      const relatedDescendantWithTooltip = getDescendantWithTooltip(relatedTarget);
      if (descendantWithTooltip && descendantWithTooltip !== relatedDescendantWithTooltip) {
        this._unpinTooltip();
      }
    } else {
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      this._unpinTooltip();
    }
  }
  /**
   * Handles hiding tooltips on `scroll` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onScroll(evt, { target }) {
    if (!this._currentElementWithTooltip) {
      return;
    }
    if (target.contains(this.balloonPanelView.element) && target.contains(this._currentElementWithTooltip)) {
      return;
    }
    this._unpinTooltip();
  }
  /**
   * Pins the tooltip to a specific DOM element.
   *
   * @param options.text Text of the tooltip to display.
   * @param options.position The position of the tooltip.
   * @param options.cssClass Additional CSS class of the balloon with the tooltip.
   */
  _pinTooltip(targetDomElement, { text, position, cssClass }) {
    const bodyViewCollection = first(_TooltipManager._editors.values()).ui.view.body;
    if (!bodyViewCollection.has(this.balloonPanelView)) {
      bodyViewCollection.add(this.balloonPanelView);
    }
    this.tooltipTextView.text = text;
    this.balloonPanelView.pin({
      target: targetDomElement,
      positions: _TooltipManager.getPositioningFunctions(position)
    });
    this._resizeObserver = new ResizeObserver(targetDomElement, () => {
      if (!isVisible(targetDomElement)) {
        this._unpinTooltip();
      }
    });
    this.balloonPanelView.class = [BALLOON_CLASS, cssClass].filter((className) => className).join(" ");
    for (const editor of _TooltipManager._editors) {
      this.listenTo(editor.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
    }
    this._currentElementWithTooltip = targetDomElement;
    this._currentTooltipPosition = position;
  }
  /**
   * Unpins the tooltip and cancels all queued pinning.
   */
  _unpinTooltip() {
    this._pinTooltipDebounced.cancel();
    this.balloonPanelView.unpin();
    for (const editor of _TooltipManager._editors) {
      this.stopListening(editor.ui, "update");
    }
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  /**
   * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
   *
   * Hides the tooltip when the element is no longer visible in DOM.
   */
  _updateTooltipPosition() {
    if (!isVisible(this._currentElementWithTooltip)) {
      this._unpinTooltip();
      return;
    }
    this.balloonPanelView.pin({
      target: this._currentElementWithTooltip,
      positions: _TooltipManager.getPositioningFunctions(this._currentTooltipPosition)
    });
  }
};
TooltipManager.defaultBalloonPositions = generatePositions({
  heightOffset: 5,
  sideOffset: 13
});
TooltipManager._editors = /* @__PURE__ */ new Set();
TooltipManager._instance = null;
function getDescendantWithTooltip(element) {
  if (!isElement_default(element)) {
    return null;
  }
  return element.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
}
function getTooltipData(element) {
  return {
    text: element.dataset.ckeTooltipText,
    position: element.dataset.ckeTooltipPosition || "s",
    cssClass: element.dataset.ckeTooltipClass || ""
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/poweredby.js
import poweredByIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/project-logo.svg";
var ICON_WIDTH = 53;
var ICON_HEIGHT = 10;
var NARROW_ROOT_HEIGHT_THRESHOLD = 50;
var NARROW_ROOT_WIDTH_THRESHOLD = 350;
var DEFAULT_LABEL = "Powered by";
var PoweredBy = class extends DomEmitterMixin() {
  /**
   * Creates a "powered by" helper for a given editor. The feature is initialized on Editor#ready
   * event.
   *
   * @param editor
   */
  constructor(editor) {
    super();
    this.editor = editor;
    this._balloonView = null;
    this._lastFocusedEditableElement = null;
    this._showBalloonThrottled = throttle_default(this._showBalloon.bind(this), 50, { leading: true });
    editor.on("ready", this._handleEditorReady.bind(this));
  }
  /**
   * Destroys the "powered by" helper along with its view.
   */
  destroy() {
    const balloon = this._balloonView;
    if (balloon) {
      balloon.unpin();
      this._balloonView = null;
    }
    this._showBalloonThrottled.cancel();
    this.stopListening();
  }
  /**
   * Enables "powered by" label once the editor (ui) is ready.
   */
  _handleEditorReady() {
    const editor = this.editor;
    const forceVisible = !!editor.config.get("ui.poweredBy.forceVisible");
    if (!forceVisible && verifyLicense(editor.config.get("licenseKey")) === "VALID") {
      return;
    }
    if (!editor.ui.view) {
      return;
    }
    editor.ui.focusTracker.on("change:isFocused", (evt, data, isFocused) => {
      this._updateLastFocusedEditableElement();
      if (isFocused) {
        this._showBalloon();
      } else {
        this._hideBalloon();
      }
    });
    editor.ui.focusTracker.on("change:focusedElement", (evt, data, focusedElement) => {
      this._updateLastFocusedEditableElement();
      if (focusedElement) {
        this._showBalloon();
      }
    });
    editor.ui.on("update", () => {
      this._showBalloonThrottled();
    });
  }
  /**
   * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
   * with the "powered by" view inside ready for positioning.
   */
  _createBalloonView() {
    const editor = this.editor;
    const balloon = this._balloonView = new BalloonPanelView();
    const poweredByConfig = getNormalizedConfig(editor);
    const view = new PoweredByView(editor.locale, poweredByConfig.label);
    balloon.content.add(view);
    balloon.set({
      class: "ck-powered-by-balloon"
    });
    editor.ui.view.body.add(balloon);
    editor.ui.focusTracker.add(balloon.element);
    this._balloonView = balloon;
  }
  /**
   * Attempts to display the balloon with the "powered by" view.
   */
  _showBalloon() {
    if (!this._lastFocusedEditableElement) {
      return;
    }
    const attachOptions = getBalloonAttachOptions(this.editor, this._lastFocusedEditableElement);
    if (attachOptions) {
      if (!this._balloonView) {
        this._createBalloonView();
      }
      this._balloonView.pin(attachOptions);
    }
  }
  /**
   * Hides the "powered by" balloon if already visible.
   */
  _hideBalloon() {
    if (this._balloonView) {
      this._balloonView.unpin();
    }
  }
  /**
   * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
   */
  _updateLastFocusedEditableElement() {
    const editor = this.editor;
    const isFocused = editor.ui.focusTracker.isFocused;
    const focusedElement = editor.ui.focusTracker.focusedElement;
    if (!isFocused || !focusedElement) {
      this._lastFocusedEditableElement = null;
      return;
    }
    const editableEditorElements = Array.from(editor.ui.getEditableElementsNames()).map((name) => {
      return editor.ui.getEditableElement(name);
    });
    if (editableEditorElements.includes(focusedElement)) {
      this._lastFocusedEditableElement = focusedElement;
    } else {
      this._lastFocusedEditableElement = editableEditorElements[0];
    }
  }
};
var PoweredByView = class extends View {
  /**
   * Created an instance of the "powered by" view.
   *
   * @param locale The localization services instance.
   * @param label The label text.
   */
  constructor(locale, label) {
    super(locale);
    const iconView = new IconView();
    const bind = this.bindTemplate;
    iconView.set({
      content: poweredByIcon,
      isColorInherited: false
    });
    iconView.extendTemplate({
      attributes: {
        style: {
          width: ICON_WIDTH + "px",
          height: ICON_HEIGHT + "px"
        }
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-powered-by"],
        "aria-hidden": true
      },
      children: [
        {
          tag: "a",
          attributes: {
            href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
            target: "_blank",
            tabindex: "-1"
          },
          children: [
            ...label ? [
              {
                tag: "span",
                attributes: {
                  class: ["ck", "ck-powered-by__label"]
                },
                children: [label]
              }
            ] : [],
            iconView
          ],
          on: {
            dragstart: bind.to((evt) => evt.preventDefault())
          }
        }
      ]
    });
  }
};
function getBalloonAttachOptions(editor, focusedEditableElement) {
  const poweredByConfig = getNormalizedConfig(editor);
  const positioningFunction = poweredByConfig.side === "right" ? getLowerRightCornerPosition(focusedEditableElement, poweredByConfig) : getLowerLeftCornerPosition(focusedEditableElement, poweredByConfig);
  return {
    target: focusedEditableElement,
    positions: [positioningFunction]
  };
}
function getLowerRightCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect, balloonRect) => {
    return rootRect.left + rootRect.width - balloonRect.width - config.horizontalOffset;
  });
}
function getLowerLeftCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect) => rootRect.left + config.horizontalOffset);
}
function getLowerCornerPosition(focusedEditableElement, config, getBalloonLeft) {
  return (visibleEditableElementRect, balloonRect) => {
    const editableElementRect = new Rect(focusedEditableElement);
    if (editableElementRect.width < NARROW_ROOT_WIDTH_THRESHOLD || editableElementRect.height < NARROW_ROOT_HEIGHT_THRESHOLD) {
      return null;
    }
    let balloonTop;
    if (config.position === "inside") {
      balloonTop = editableElementRect.bottom - balloonRect.height;
    } else {
      balloonTop = editableElementRect.bottom - balloonRect.height / 2;
    }
    balloonTop -= config.verticalOffset;
    const balloonLeft = getBalloonLeft(editableElementRect, balloonRect);
    const newBalloonPositionRect = visibleEditableElementRect.clone().moveTo(balloonLeft, balloonTop).getIntersection(balloonRect.clone().moveTo(balloonLeft, balloonTop));
    const newBalloonPositionVisibleRect = newBalloonPositionRect.getVisible();
    if (!newBalloonPositionVisibleRect || newBalloonPositionVisibleRect.getArea() < balloonRect.getArea()) {
      return null;
    }
    return {
      top: balloonTop,
      left: balloonLeft,
      name: `position_${config.position}-side_${config.side}`,
      config: {
        withArrow: false
      }
    };
  };
}
function getNormalizedConfig(editor) {
  const userConfig = editor.config.get("ui.poweredBy");
  const position = userConfig && userConfig.position || "border";
  return {
    position,
    label: DEFAULT_LABEL,
    verticalOffset: position === "inside" ? 5 : 0,
    horizontalOffset: 5,
    side: editor.locale.contentLanguageDirection === "ltr" ? "right" : "left",
    ...userConfig
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/arialiveannouncer.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/arialiveannouncer/arialiveannouncer.css";
var AriaLiveAnnouncerPoliteness;
(function(AriaLiveAnnouncerPoliteness2) {
  AriaLiveAnnouncerPoliteness2["POLITE"] = "polite";
  AriaLiveAnnouncerPoliteness2["ASSERTIVE"] = "assertive";
})(AriaLiveAnnouncerPoliteness || (AriaLiveAnnouncerPoliteness = {}));
var AriaLiveAnnouncer = class {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    this.editor = editor;
  }
  /**
   * Sets an announcement text to an aria region associated with a specific editor feature. The text is then
   * announced by a screen reader to the user.
   *
   * If the aria region of a given name does not exist, it will be created and can be re-used later. The name of the region
   * groups announcements originating from a specific editor feature and does not get announced by a screen reader.
   *
   * Using multiple regions allows for many announcements to be emitted in a short period of time. Changes to ARIA-live announcements
   * are captured by a screen reader and read out in the order they were emitted.
   *
   * The default announcement politeness level is `'polite'`.
   *
   * ```ts
   * // Most screen readers will queue announcements from multiple aria-live regions and read them out in the order they were emitted.
   * editor.ui.ariaLiveAnnouncer.announce( 'image', 'Image uploaded.' );
   * editor.ui.ariaLiveAnnouncer.announce( 'network', 'Connection lost. Reconnecting.' );
   * ```
   */
  announce(regionName, announcementText, politeness = AriaLiveAnnouncerPoliteness.POLITE) {
    const editor = this.editor;
    if (!this.view) {
      this.view = new AriaLiveAnnouncerView(editor.locale);
      editor.ui.view.body.add(this.view);
    }
    let regionView = this.view.regionViews.find((view) => view.regionName === regionName);
    if (!regionView) {
      regionView = new AriaLiveAnnouncerRegionView(this.view.locale);
      this.view.regionViews.add(regionView);
    }
    regionView.set({
      regionName,
      text: announcementText,
      politeness
    });
  }
};
var AriaLiveAnnouncerView = class extends View {
  constructor(locale) {
    super(locale);
    this.regionViews = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-aria-live-announcer"
        ]
      },
      children: this.regionViews
    });
  }
};
var AriaLiveAnnouncerRegionView = class extends View {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("regionName", "");
    this.set("text", "");
    this.set("politeness", AriaLiveAnnouncerPoliteness.POLITE);
    this.setTemplate({
      tag: "div",
      attributes: {
        role: "region",
        "data-region": bind.to("regionName"),
        "aria-live": bind.to("politeness")
      },
      children: [
        { text: bind.to("text") }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editorui.js
var EditorUI = class extends ObservableMixin() {
  /**
   * Creates an instance of the editor UI class.
   *
   * @param editor The editor instance.
   */
  constructor(editor) {
    super();
    this.isReady = false;
    this._editableElementsMap = /* @__PURE__ */ new Map();
    this._focusableToolbarDefinitions = [];
    const editingView = editor.editing.view;
    this.editor = editor;
    this.componentFactory = new ComponentFactory(editor);
    this.focusTracker = new FocusTracker();
    this.tooltipManager = new TooltipManager(editor);
    this.poweredBy = new PoweredBy(editor);
    this.ariaLiveAnnouncer = new AriaLiveAnnouncer(editor);
    this.set("viewportOffset", this._readViewportOffsetFromConfig());
    this.once("ready", () => {
      this.isReady = true;
    });
    this.listenTo(editingView.document, "layoutChanged", this.update.bind(this));
    this.listenTo(editingView, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
    this._initFocusTracking();
  }
  /**
   * The main (outermost) DOM element of the editor UI.
   *
   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
   * it is the editable element itself (as there is no other wrapper). However, in
   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
   * come with a single "main" HTML element (its editable element and toolbar are separate).
   *
   * This property can be understood as a shorthand for retrieving the element that a specific editor integration
   * considers to be its main DOM element.
   */
  get element() {
    return null;
  }
  /**
   * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
   *
   * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
   * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
   */
  update() {
    this.fire("update");
  }
  /**
   * Destroys the UI.
   */
  destroy() {
    this.stopListening();
    this.focusTracker.destroy();
    this.tooltipManager.destroy(this.editor);
    this.poweredBy.destroy();
    for (const domElement of this._editableElementsMap.values()) {
      domElement.ckeditorInstance = null;
      this.editor.keystrokes.stopListening(domElement);
    }
    this._editableElementsMap = /* @__PURE__ */ new Map();
    this._focusableToolbarDefinitions = [];
  }
  /**
   * Stores the native DOM editable element used by the editor under a unique name.
   *
   * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
   * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
   *
   * @param rootName The unique name of the editable element.
   * @param domElement The native DOM editable element.
   */
  setEditableElement(rootName, domElement) {
    this._editableElementsMap.set(rootName, domElement);
    if (!domElement.ckeditorInstance) {
      domElement.ckeditorInstance = this.editor;
    }
    this.focusTracker.add(domElement);
    const setUpKeystrokeHandler = () => {
      if (this.editor.editing.view.getDomRoot(rootName)) {
        return;
      }
      this.editor.keystrokes.listenTo(domElement);
    };
    if (this.isReady) {
      setUpKeystrokeHandler();
    } else {
      this.once("ready", setUpKeystrokeHandler);
    }
  }
  /**
   * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
   *
   * @param rootName The name of the editable element to remove.
   */
  removeEditableElement(rootName) {
    const domElement = this._editableElementsMap.get(rootName);
    if (!domElement) {
      return;
    }
    this._editableElementsMap.delete(rootName);
    this.editor.keystrokes.stopListening(domElement);
    this.focusTracker.remove(domElement);
    domElement.ckeditorInstance = null;
  }
  /**
   * Returns the editable editor element with the given name or null if editable does not exist.
   *
   * @param rootName The editable name.
   */
  getEditableElement(rootName = "main") {
    return this._editableElementsMap.get(rootName);
  }
  /**
   * Returns array of names of all editor editable elements.
   */
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  /**
   * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
   *
   * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
   * Successive keystroke presses navigate over available toolbars.
   *
   * @param toolbarView A instance of the toolbar to be registered.
   */
  addToolbar(toolbarView, options = {}) {
    if (toolbarView.isRendered) {
      this.focusTracker.add(toolbarView.element);
      this.editor.keystrokes.listenTo(toolbarView.element);
    } else {
      toolbarView.once("render", () => {
        this.focusTracker.add(toolbarView.element);
        this.editor.keystrokes.listenTo(toolbarView.element);
      });
    }
    this._focusableToolbarDefinitions.push({ toolbarView, options });
  }
  /**
   * Stores all editable elements used by the editor instance.
   *
   * @deprecated
   */
  get _editableElements() {
    console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this });
    return this._editableElementsMap;
  }
  /**
   * Returns viewport offsets object:
   *
   * ```js
   * {
   * 	top: Number,
   * 	right: Number,
   * 	bottom: Number,
   * 	left: Number
   * }
   * ```
   *
   * Only top property is currently supported.
   */
  _readViewportOffsetFromConfig() {
    const editor = this.editor;
    const viewportOffsetConfig = editor.config.get("ui.viewportOffset");
    if (viewportOffsetConfig) {
      return viewportOffsetConfig;
    }
    const legacyOffsetConfig = editor.config.get("toolbar.viewportTopOffset");
    if (legacyOffsetConfig) {
      console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
      return { top: legacyOffsetConfig };
    }
    return { top: 0 };
  }
  /**
   * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
   * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
   * to allow users navigate across the UI.
   */
  _initFocusTracking() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    let lastFocusedForeignElement;
    let candidateDefinitions;
    editor.keystrokes.set("Alt+F10", (data, cancel) => {
      const focusedElement = this.focusTracker.focusedElement;
      if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(editingView.domRoots.values()).includes(focusedElement)) {
        lastFocusedForeignElement = focusedElement;
      }
      const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();
      if (!currentFocusedToolbarDefinition || !candidateDefinitions) {
        candidateDefinitions = this._getFocusableCandidateToolbarDefinitions();
      }
      for (let i = 0; i < candidateDefinitions.length; i++) {
        const candidateDefinition = candidateDefinitions.shift();
        candidateDefinitions.push(candidateDefinition);
        if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {
          if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {
            currentFocusedToolbarDefinition.options.afterBlur();
          }
          break;
        }
      }
      cancel();
    });
    editor.keystrokes.set("Esc", (data, cancel) => {
      const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();
      if (!focusedToolbarDef) {
        return;
      }
      if (lastFocusedForeignElement) {
        lastFocusedForeignElement.focus();
        lastFocusedForeignElement = null;
      } else {
        editor.editing.view.focus();
      }
      if (focusedToolbarDef.options.afterBlur) {
        focusedToolbarDef.options.afterBlur();
      }
      cancel();
    });
  }
  /**
   * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
   *
   * Focusable toolbars candidates are either:
   * * already visible,
   * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
   * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
   * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
   *
   * **Note**: Contextual toolbars take precedence over regular toolbars.
   */
  _getFocusableCandidateToolbarDefinitions() {
    const definitions = [];
    for (const toolbarDef of this._focusableToolbarDefinitions) {
      const { toolbarView, options } = toolbarDef;
      if (isVisible(toolbarView.element) || options.beforeFocus) {
        definitions.push(toolbarDef);
      }
    }
    definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));
    return definitions;
  }
  /**
   * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
   *
   * `null` is returned when no toolbar is currently focused.
   */
  _getCurrentFocusedToolbarDefinition() {
    for (const definition of this._focusableToolbarDefinitions) {
      if (definition.toolbarView.element && definition.toolbarView.element.contains(this.focusTracker.focusedElement)) {
        return definition;
      }
    }
    return null;
  }
  /**
   * Focuses a focusable toolbar candidate using its definition.
   *
   * @param candidateToolbarDefinition A definition of the toolbar to focus.
   * @returns `true` when the toolbar candidate was focused. `false` otherwise.
   */
  _focusFocusableCandidateToolbar(candidateToolbarDefinition) {
    const { toolbarView, options: { beforeFocus } } = candidateToolbarDefinition;
    if (beforeFocus) {
      beforeFocus();
    }
    if (!isVisible(toolbarView.element)) {
      return false;
    }
    toolbarView.focus();
    return true;
  }
  /**
   * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
   * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
   *
   * @param evt The `scrollToTheSelection` event info.
   * @param data The payload carried by the `scrollToTheSelection` event.
   */
  _handleScrollToTheSelection(evt, data) {
    const configuredViewportOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this.viewportOffset
    };
    data.viewportOffset.top += configuredViewportOffset.top;
    data.viewportOffset.bottom += configuredViewportOffset.bottom;
    data.viewportOffset.left += configuredViewportOffset.left;
    data.viewportOffset.right += configuredViewportOffset.right;
  }
};
function getToolbarDefinitionWeight(toolbarDef) {
  const { toolbarView, options } = toolbarDef;
  let weight = 10;
  if (isVisible(toolbarView.element)) {
    weight--;
  }
  if (options.isContextual) {
    weight--;
  }
  return weight;
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/editorui/editorui.css";

// node_modules/@ckeditor/ckeditor5-ui/src/formheader/formheaderview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css";

// node_modules/@ckeditor/ckeditor5-ui/src/model.js
var Model = class extends ObservableMixin() {
  /**
   * Creates a new Model instance.
   *
   * @param attributes The model state attributes to be defined during the instance creation.
   * @param properties The (out of state) properties to be appended to the instance during creation.
   */
  constructor(attributes, properties) {
    super();
    if (properties) {
      assignIn_default(this, properties);
    }
    if (attributes) {
      this.set(attributes);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js
import prevIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/previous-arrow.svg";
import nextIcon from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/next-arrow.svg";
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css";
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css";
var toPx2 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css";
var toPx3 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/search/text/searchtextqueryview.js
var SearchTextQueryView = class extends LabeledFieldView {
  /**
   * @inheritDoc
   */
  constructor(locale, config) {
    const t = locale.t;
    const viewConfig = Object.assign({}, {
      showResetButton: true,
      showIcon: true,
      creator: createLabeledInputText
    }, config);
    super(locale, viewConfig.creator);
    this.label = config.label;
    this._viewConfig = viewConfig;
    if (this._viewConfig.showIcon) {
      this.iconView = new IconView();
      this.iconView.content = icons.loupe;
      this.fieldWrapperChildren.add(this.iconView, 0);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-icon"
        }
      });
    }
    if (this._viewConfig.showResetButton) {
      this.resetButtonView = new ButtonView(locale);
      this.resetButtonView.set({
        label: t("Clear"),
        icon: icons.cancel,
        class: "ck-search__reset",
        isVisible: false,
        tooltip: true
      });
      this.resetButtonView.on("execute", () => {
        this.reset();
        this.focus();
        this.fire("reset");
      });
      this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (isEmpty) => !isEmpty);
      this.fieldWrapperChildren.add(this.resetButtonView);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-reset"
        }
      });
    }
  }
  /**
   * Resets the search field to its default state.
   */
  reset() {
    this.fieldView.reset();
    if (this._viewConfig.showResetButton) {
      this.resetButtonView.isVisible = false;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/search/searchinfoview.js
var SearchInfoView = class extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set({
      isVisible: false,
      primaryText: "",
      secondaryText: ""
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__info",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        tabindex: -1
      },
      children: [
        {
          tag: "span",
          children: [
            {
              text: [bind.to("primaryText")]
            }
          ]
        },
        {
          tag: "span",
          children: [
            {
              text: [bind.to("secondaryText")]
            }
          ]
        }
      ]
    });
  }
  /**
   * Focuses the view
   */
  focus() {
    this.element.focus();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/search/searchresultsview.js
var SearchResultsView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__results"
        ],
        tabindex: -1
      },
      children: this.children
    });
    this._focusCycler = new FocusCycler({
      focusables: this.children,
      focusTracker: this.focusTracker
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const child of this.children) {
      this.focusTracker.add(child.element);
    }
  }
  /**
   * Focuses the view.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the first child view.
   */
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last child view.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/search/text/searchtextview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/search/search.css";
var SearchTextView = class extends View {
  /**
   * Creates an instance of the {@link module:ui/search/text/searchtextview~SearchTextView} class.
   *
   * @param locale The localization services instance.
   * @param config Configuration of the view.
   */
  constructor(locale, config) {
    super(locale);
    this._config = config;
    this.filteredView = config.filteredView;
    this.queryView = this._createSearchTextQueryView();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.resultsView = new SearchResultsView(locale);
    this.children = this.createCollection();
    this.focusableChildren = this.createCollection([this.queryView, this.resultsView]);
    this.set("isEnabled", true);
    this.set("resultsCount", 0);
    this.set("totalItemsCount", 0);
    if (config.infoView && config.infoView.instance) {
      this.infoView = config.infoView.instance;
    } else {
      this.infoView = new SearchInfoView();
      this._enableDefaultInfoViewBehavior();
      this.on("render", () => {
        this.search("");
      });
    }
    this.resultsView.children.addMany([this.infoView, this.filteredView]);
    this.focusCycler = new FocusCycler({
      focusables: this.focusableChildren,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.on("search", (evt, { resultsCount, totalItemsCount }) => {
      this.resultsCount = resultsCount;
      this.totalItemsCount = totalItemsCount;
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search",
          config.class || null
        ],
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.addMany([
      this.queryView,
      this.resultsView
    ]);
    const stopPropagation = (data) => data.stopPropagation();
    for (const focusableChild of this.focusableChildren) {
      this.focusTracker.add(focusableChild.element);
    }
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
   * Focuses the {@link #queryView}.
   */
  focus() {
    this.queryView.focus();
  }
  /**
   * Resets the component to its initial state.
   */
  reset() {
    this.queryView.reset();
    this.search("");
  }
  /**
   * Searches the {@link #filteredView} for the given query.
   *
   * @internal
   * @param query The search query string.
   */
  search(query) {
    const regExp = query ? new RegExp(escapeRegExp_default(query), "ig") : null;
    const filteringResults = this.filteredView.filter(regExp);
    this.fire("search", { query, ...filteringResults });
  }
  /**
   * Creates a search field view based on configured creator..
   */
  _createSearchTextQueryView() {
    const queryView = new SearchTextQueryView(this.locale, this._config.queryView);
    this.listenTo(queryView.fieldView, "input", () => {
      this.search(queryView.fieldView.element.value);
    });
    queryView.on("reset", () => this.reset());
    queryView.bind("isEnabled").to(this);
    return queryView;
  }
  /**
   * Initializes the default {@link #infoView} behavior with default text labels when no custom info view
   * was specified in the view config.
   */
  _enableDefaultInfoViewBehavior() {
    const t = this.locale.t;
    const infoView = this.infoView;
    this.on("search", (evt, data) => {
      if (!data.resultsCount) {
        const defaultTextConfig = this._config.infoView && this._config.infoView.text;
        let primaryText, secondaryText;
        if (data.totalItemsCount) {
          if (defaultTextConfig && defaultTextConfig.notFound) {
            primaryText = defaultTextConfig.notFound.primary;
            secondaryText = defaultTextConfig.notFound.secondary;
          } else {
            primaryText = t("No results found");
            secondaryText = "";
          }
        } else {
          if (defaultTextConfig && defaultTextConfig.noSearchableItems) {
            primaryText = defaultTextConfig.noSearchableItems.primary;
            secondaryText = defaultTextConfig.noSearchableItems.secondary;
          } else {
            primaryText = t("No searchable items");
            secondaryText = "";
          }
        }
        infoView.set({
          primaryText: normalizeInfoText(primaryText, data),
          secondaryText: normalizeInfoText(secondaryText, data),
          isVisible: true
        });
      } else {
        infoView.set({
          isVisible: false
        });
      }
    });
    function normalizeInfoText(text, { query, resultsCount, totalItemsCount }) {
      return typeof text === "function" ? text(query, resultsCount, totalItemsCount) : text;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/autocomplete/autocompleteview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/autocomplete/autocomplete.css";
var AutocompleteView = class _AutocompleteView extends SearchTextView {
  /**
   * @inheritDoc
   */
  constructor(locale, config) {
    super(locale, config);
    this._config = config;
    const toPx7 = toUnit("px");
    this.extendTemplate({
      attributes: {
        class: ["ck-autocomplete"]
      }
    });
    const bindResultsView = this.resultsView.bindTemplate;
    this.resultsView.set("isVisible", false);
    this.resultsView.set("_position", "s");
    this.resultsView.set("_width", 0);
    this.resultsView.extendTemplate({
      attributes: {
        class: [
          bindResultsView.if("isVisible", "ck-hidden", (value) => !value),
          bindResultsView.to("_position", (value) => `ck-search__results_${value}`)
        ],
        style: {
          width: bindResultsView.to("_width", toPx7)
        }
      }
    });
    this.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
      this._updateResultsVisibility();
      if (isFocused) {
        this.resultsView.element.scrollTop = 0;
      } else if (config.resetOnBlur) {
        this.queryView.reset();
      }
    });
    this.on("search", () => {
      this._updateResultsVisibility();
      this._updateResultsViewWidthAndPosition();
    });
    this.keystrokes.set("esc", (evt, cancel) => {
      if (!this.resultsView.isVisible) {
        return;
      }
      this.queryView.focus();
      this.resultsView.isVisible = false;
      cancel();
    });
    this.listenTo(global_default.document, "scroll", () => {
      this._updateResultsViewWidthAndPosition();
    });
    this.on("change:isEnabled", () => {
      this._updateResultsVisibility();
    });
    this.filteredView.on("execute", (evt, { value }) => {
      this.focus();
      this.reset();
      this.queryView.fieldView.value = this.queryView.fieldView.element.value = value;
      this.resultsView.isVisible = false;
    });
    this.resultsView.on("change:isVisible", () => {
      this._updateResultsViewWidthAndPosition();
    });
  }
  /**
   * Updates the position of the results view on demand.
   */
  _updateResultsViewWidthAndPosition() {
    if (!this.resultsView.isVisible) {
      return;
    }
    this.resultsView._width = new Rect(this.queryView.fieldView.element).width;
    const optimalResultsPosition = _AutocompleteView._getOptimalPosition({
      element: this.resultsView.element,
      target: this.queryView.element,
      fitInViewport: true,
      positions: _AutocompleteView.defaultResultsPositions
    });
    this.resultsView._position = optimalResultsPosition ? optimalResultsPosition.name : "s";
  }
  /**
   * Updates the visibility of the results view on demand.
   */
  _updateResultsVisibility() {
    const queryMinChars = typeof this._config.queryMinChars === "undefined" ? 0 : this._config.queryMinChars;
    const queryLength = this.queryView.fieldView.element.value.length;
    this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && queryLength >= queryMinChars;
  }
};
AutocompleteView.defaultResultsPositions = [
  (fieldRect) => {
    return {
      top: fieldRect.bottom,
      left: fieldRect.left,
      name: "s"
    };
  },
  (fieldRect, resultsRect) => {
    return {
      top: fieldRect.top - resultsRect.height,
      left: fieldRect.left,
      name: "n"
    };
  }
];
AutocompleteView._getOptimalPosition = getOptimalPosition;

// node_modules/@ckeditor/ckeditor5-ui/src/highlightedtext/highlightedtextview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css";

// node_modules/@ckeditor/ckeditor5-ui/src/collapsible/collapsibleview.js
import dropdownArrowIcon3 from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/collapsible/collapsible.css";

// node_modules/@ckeditor/ckeditor5-ui/src/spinner/spinnerview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/spinner/spinner.css";

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/balloon/balloontoolbar.js
var toPx4 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blockbuttonview.js
import "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css";
var toPx5 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blocktoolbar.js
var toPx6 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/index.js
import { default as colorPaletteIcon2 } from "C:/wamp64/www/3dgwebdev/node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-palette.svg";

export {
  View,
  Template,
  ButtonView
};
/*! Bundled license information:

ckeditor5/src/core.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/viewcollection.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/template.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/view.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/icon/iconview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/buttonlabelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/buttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/injectcsstransitiondisabler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/csstransitiondisablermixin.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/submithandler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/addkeyboardhandlingforgrid.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/bodycollection.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorpicker/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/label/labelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/input/inputbase.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/input/inputview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/inputnumber/inputnumberview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/textarea/textareaview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/focuscycler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarlinebreakview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listitemview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listseparatorview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listitemgroupview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/labeledfield/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorpicker/colorpickerview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/documentcolorcollection.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorgridsfragmentview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorpickerfragmentview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorselectorview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/componentfactory.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/tooltipmanager.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/poweredby.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-ui/src/arialiveannouncer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/editorui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/boxed/boxededitoruiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editableui/editableuiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/formheader/formheaderview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/iframe/iframeview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/notification/notification.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/model.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/text/searchtextqueryview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/searchinfoview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/searchresultsview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/text/searchtextview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/autocomplete/autocompleteview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/highlightedtext/highlightedtextview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/collapsible/collapsibleview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/spinner/spinnerview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/balloon/balloontoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/block/blockbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/block/blocktoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-GVJYUFQW.js.map
